// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.data.gerrit.v1;
// This proto is intended to be classified as MVP (converged) maturity.
// TBD - Pending actual implementation to annotate maturity.

option go_package = "go.chromium.org/turboci/proto/go/data/gerrit/v1;gerritpb";
option java_multiple_files = true;

// GobSourceCheckOptions provides instructions on how to checkout a GoB source.
// 1. Checkout the pinned revisions of all repos referenced in the PinnedRepoMounts.
// 2. Apply zero or more repo-level (mount) overrides to checkout revisions different from
//    the pinned manifest if needed.
// 3. Apply zero or more CLs on top of the base.
message GobSourceCheckOptions {
  // Information to reference a Gerrit change at a specific patchset.
  message GerritChange {
    // Which Gerrit instance this change is hosted on. This should not include suffixes or prefixes
    // outside of the actual "host" name.
    // Eg. Use "chromium", NOT "chromium-review" or "chromium-review.git.corp.google.com"
    optional string hostname = 1;
    // Gerrit Change number, as an integer (e.g. 215798).
    optional int64 change_number = 2;
    // Gerrit patchset number, as an integer.
    optional int32 patchset = 3;

    // A list of paths to local repos ("mounts") where this change should be applied to.
    // This is needed to support cases where there may be different versions of the
    // same remote repo checked out, and a change should only be applied to a specific
    // version. If not provided, the change will be applied to all mounts of the CL's repo.
    //
    // The order of GerritChanges also controls the patching order for each mount.
    // This means that the patching order is the same for every repo. If you have a use case
    // that requires a different order per repo, reach out to the Turbo CI team by filing a
    // go/turbo-ci-bug.
    repeated string mounts_to_apply = 5;

    // Future: Devise a converged merge strategy to control how changes should be patched
    // eg. cherrypick vs merge. This would need representation both in the input (for
    // tools to control the merging strategy) as well as the output (to represent the
    // actual applied strategy in case fallbacks were used). This also cannot be per-change.
    // Eg. if a change fails to be cherry-picked and we fallback to a merge, all other changes
    // must also use merge to ensure any new dependencies from the merge are fulfilled.
  }

  // A list of Gerrit changes relevant to this run.
  // Essentially just the gerrit host, change number and patchset.
  // Required for presubmit workflows, must not be set in postsubmit where we're building
  // an already committed source.
  //
  // Sorted in the order in which the CLs should be patched, with the first CL in the list
  // being the first to be patched.
  //
  //
  // For changes which modify the superproject/manifest, these should be patched on to the
  // top-level superproject first before applying any of the mount overrides to ensure
  // the child repos are synced in accordance with the manifest changes.
  repeated GerritChange gerrit_changes = 1;

  // References a single group of mounts with all repo refs pinned. This can be a superproject
  // commit, a commit from a branch containing a manifest, or a list of root-level projects.
  //
  // You can also specify per-mount commits that override those in the commit via either inline
  // overrides or a reference to pinned manifest metadata stored in Android's manifest
  // store service.
  message PinnedRepoMounts {
    // References a landed Git commit.
    message GitCommit {
      // GoB host without the ".googlesource.com" hostname suffix as the suffix may
      // be different depending on how it's accessed (eg. ".git.corp.google.com")
      // while still referring to the same repo.
      optional string host = 1;
      // Repository name on the host, e.g. "chromium/src".
      optional string project = 2;
      // Commit ID (eg. HEX SHA1).
      optional string id = 3;
      // Commit ref, e.g. "refs/heads/main".
      // NOT a branch name: if specified, MUST start with "refs/".
      // If no id is set, the referenced commit is HEAD on the ref.
      // If both ref and id are set, the commit id specifies which commit to use, and the
      // ref is simply informative to describe which branch the commit is found on.
      // If id is set and ref is not, this means to use the commit ID on the branch whose
      // ref is in the manifest.
      optional string ref = 4;
    }

    // Commit for a manifest with the path to the manifest file. This manifest may be
    // pinned (all mounts referencing a fixed commit), or it may be unpinned (some mounts
    // referencing a branch ref) in which case the per-repo commits need to be provided
    // via mount_overrides.
    message ManifestCommit {
      // The git commit for the manifest.
      optional GitCommit commit = 1;
      // Path to the manifest file within the repo for the given commit.
      optional string path = 2;
    }

    // References pinned repos, either as a superproject commit, a commit from a branch containing
    // a manifest, or a list of root-level projects.
    oneof pinned_repos {
      // This is the commit for a project which may or may not be a superproject that contain other
      // projects. If it is a superproject, it could have pinned revisions or floating refs
      // (which will then be pinned by mount_overrides) for all subprojects.
      //
      // If you have multiple root-level projects to checkout, use multiple SourceChecks.
      GitCommit project_commit = 1;

      // Commit for a manifest with the path to the manifest file.
      ManifestCommit manifest_commit = 2;
    }

    // Used to override a repo checkout on disk (mount) to a specific commit ID.
    message MountOverride {
      // This should point to the commit ID you want to override with.
      optional GitCommit override = 1;

      // The local path to the repo checkout you want to override.
      optional string mount = 2;
    }

    // Per-mount overrides for the revisions listed by the superproject/manifest.
    // Used if a workflow needs to check out a different revision than what is pinned
    // by the superproject/manifest, or to specify pins if the manifest specifies
    // branches rather than pinned commits. Could be used to specify per-repo commits
    // without specifying a manifest or superproject, though we're not aware of any
    // PDEIO workflows that currently need this.
    //
    // Order matters here. Overrides will be performed from first to last index.
    // If you need an override to happen before another, order them appropriately.
    // If your ordering becomes too complex to represent here, talk to the CIC team.
    //
    // An example of an override use case that does not work well here is overriding
    // submodules nested within other submodules. If the parent submodule commit is
    // overridden, we would need to re-evaluate its child submodules and potentially
    // override them again. We do not anticipate a use case for this today, but if you
    // have one, talk to the CIC team.
    repeated MountOverride mount_overrides = 3;
  }

  // A "base" checkout state on which we apply changes.
  // For a postsubmit workflow, this just represents the committed source we want to build
  // and likely won't have any additional changes to apply.
  //
  // If the original input options (e.g. for presubmit workflow) did not set a base_pinned_repos,
  // it will be populated by a CheckEdit once the SourceCheck is processed.
  // The one exception is for Android presubmit workflows, where we potentially select different
  // reference builds for different build targets and we want to avoid duplicating the ChangeInfos
  // (which can be be very large for merge commits) by making separate Source Checks for each build
  // target. In those cases, we will store the build_id for the selected reference build in the
  // Build Check, and any Stages looking to understand the source code being referenced will need
  // to understand that relationship and pull the reference build_id from the Build Check and then
  // use that to get the manifest it used, to combine with the info in the Source Check.
  optional PinnedRepoMounts base_pinned_repos = 4;
}
