// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/orchestrator/v1/edge.proto";
import "turboci/graph/orchestrator/v1/revision.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Dependencies represents a group of edges (the predicate) needed to unblock
// a containing node (a Check or a Stage), as well as timestamps and
// satisfaction of those edges, and finally an overall assessment of the
// resolution of the predicate.
//
// During PLANNING, the `edges` and `predicate` fields are mutable. These
// contain all dependency targets and any criteria for them, plus the boolean
// logic of which subset of these edges are necessary to unblock the node. The
// orchestrator will convert WriteNodesRequest.DependencyGroup into `edges` and
// `predicate` for the client.
//
// As soon as the containing node is PLANNED, the orchestrator will begin
// tracking resolution of the edges. As they are resolved, these 'resolution
// events' are recorded to the the `resolution_events` field.
//
// Finally, once enough resolution events are present such that the `predicate`
// Group can be resolved, the orchestrator will set the `resolution` field.
message Dependencies {
  // A group of dependencies, containing edges and/or other groups, plus
  // a minimum threshold to meet to consider this Group satisfied.
  //
  // A Group forms a boolean logic expression of edge satisfiability (e.g. `(A
  // && B) || C`). In the basic case with `threshold` unset, a Group is an `AND`
  // of all contained edges/groups. With threshold == 1, a Group is an `OR` of
  // all contained edges/groups.
  message Group {
    // Singular edges in this group.
    //
    // Kept sorted; values are indexes into `Dependencies.edges`.
    repeated int32 edges = 1;

    // Sub-groups in this group.
    //
    // May not contain empty groups.
    repeated Group groups = 2;

    // If unset, all `edges` and `groups` must be satisfied for this Group to
    // be satisfied (effectively 'AND' of edges and groups).
    //
    // If set, indicates the number of edges and groups needed to resolve this
    // Group.
    //
    // Setting threshold to `1` effectively means 'the first satisfied entry in
    // edges or groups satisfies this group' (effectively making this an OR).
    //
    // A value greater than `1` could be useful if you want to depend on the
    // first N of multiple possible edges.
    //
    // For example, if this Group is
    //
    //    { edges: [a, b, c], groups: [GROUP], threshold: 2 }
    //
    // Then this Group could be satisfied on the first of any:
    //   * a b
    //   * b c
    //   * a c
    //   * a GROUP
    //   * b GROUP
    //   * c GROUP
    //
    // This is also equivalent to the much more verbose disjunctive normal form:
    //
    //   { groups: [
    //     { edges: [a, b] },
    //     { edges: [b, c] },
    //     { edges: [a, c] },
    //     { edges: [a], groups: [GROUP] },
    //     { edges: [b], groups: [GROUP] },
    //     { edges: [c], groups: [GROUP] },
    //     threshold = 1,
    //   }
    //
    // NOTE: It is possible for a Group in `Dependencies.satisfied` to contain
    // more edges/groups than `threshold` if all of those Edges were satisfied
    // at the time the Dependencies were resolved.
    //
    // A threshold less than zero is an error.
    // A threshold greater than `len(edges) + len(groups)` is an error.
    //
    // A threshold equal to zero or a threshold equal to `len(edges)
    // + len(groups)` will be normalized to `unset`.
    optional int32 threshold = 3;
  }

  // The set of all edges from the containing node to other nodes in the graph.
  //
  // These are unique by `target` and `condition` (expressions will be lightly
  // normalized for e.g. whitespace, comments, but this will not attempt to do
  // any 'smart' deduplication of semantically equivalent expressions).
  //
  // See `predicate` and `satisfied` which refer to these.
  repeated Edge edges = 1;

  // The logical predicate that the containing node depends on.
  //
  // The Group is a compact expression of a logical rule of which edges must be
  // satisfied before the node can be unblocked.
  //
  // Once the containing node is CHECK_STATE_WAITING/STAGE_STATE_ATTEMPTING,
  // this field is immutable.
  optional Group predicate = 2;

  // ResolutionEvent is a detail of when a specific target Edge in `edges`
  // was resolved for the containing node.
  //
  // This MAY include non-zero propagation time from the time that the target of
  // Edge entered a satisfying state for this Edge.
  message ResolutionEvent {
    // The version of the containing node which included this event.
    //
    // This MAY be substantially after the target of the edge is FINAL, e.g. if
    // the containing node was created or became PLANNED far after the target
    // was FINAL.
    optional Revision version = 1;

    // Was the criteria for this edge satisfied or not?
    //
    // Will never be `UNKNOWN`.
    optional Resolution resolution = 2;
  }
  // While containing node is in the PLANNED state, this will accumulate all
  // incoming resolution events.
  //
  // The key is an index into the Dependencies.edges list.
  //
  // When the containing node enters PLANNED for the first time, there may be
  // several events which show up here immediately (i.e. the targets of these
  // Edges were already resolved when the node entered PLANNED).
  //
  // This field is append-only; once an Edge has a ResolutionEvent, that
  // resolution will never change.
  map<int32, ResolutionEvent> resolution_events = 3;

  // When the orchestrator recognizes that the events in `resolution_events` can
  // resolve the `predicate` Group, it will set this field to either
  // RESOLUTION_SATISFIED or RESOLUTION_UNSATISFIED.
  //
  // If this is RESOLUTION_SATISFIED, the containing node will move to the
  // CHECK_STATE_WAITING or STAGE_STATE_ATTEMPTING state, depending on the
  // containing node type.
  //
  // If this is RESOLUTION_UNSATISFIED, then the containing node will be
  // immediately moved to its FINAL state. For Checks, a single Result will be
  // added with type `TBD`.
  //
  // Once set, this is immutable.
  //
  // The subset of `predicate` which caused these Dependencies to be satisfied
  // can be recovered like:
  //
  //     satisfied_edges = {
  //       idx
  //       for idx, event in deps.resolution_events
  //       if event.resolution == RESOLUTION_SATISFIED
  //     }
  //     def visit(group: Dependencies.Group) -> Dependencies.Group|None:
  //       edges = [idx for idx in group.edges if idx in satisfied_edges]
  //       groups = [
  //         visited for subgroup in group.groups
  //         if (visited := visit(subgroup))
  //       ]
  //       threshold = group.threshold or (len(group.edges) + len(group.groups))
  //       if len(edges) + len(groups) < threshold:
  //         return None
  //       return Dependencies.Group(
  //         edges=edges, groups=groups,
  //         threshold=group.threshold
  //       )
  //     predicate_subset = visit(deps.predicate)
  optional Resolution resolution = 4;
}
