// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/api/field_behavior.proto";
import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/actor.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/dependencies.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_state.proto";
import "turboci/graph/orchestrator/v1/stage_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_state.proto";
import "turboci/graph/orchestrator/v1/value.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// A Stage is an executable node in the workflow.
//
// The Orchestrator will coordinate with the Executor which is registered to
// match `args.type_url` to actually run the Stage.
//
// See also:
//   * StageView (graph view object for a Stage and contained messages)
//   * StageEditView (graph view object for Edits of a Stage)
message Stage {
  // The Stage's identifier.
  optional ids.v1.Stage identifier = 1 [(google.api.field_behavior) = IMMUTABLE];

  // Actor which created the Stage.
  optional Actor created_by = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The security realm for this Stage.
  //
  // When a Stage inserts another, the inserted Stage will inherit the realm of
  // the inserting Stage, unless this is explicitly set.
  optional string realm = 3 [(google.api.field_behavior) = IMMUTABLE];

  // The arguments of the Stage.
  //
  // `identifier` is always empty.
  //
  // The type of this Datum must be pre-registered with the Orchestrator, and
  // that registration will indicate which Executor should handle this Stage.
  //
  // NOTE: It's assumed that args.type_url will be a sufficient routing key to
  // the various registered Executors, but it's POSSIBLE that we may need to
  // have multiple Executors handle exactly the same Stage type, at which point
  // we would need to either:
  //   * Add a secondary type to distinguish them; this would have the
  //     additional benefit of allowing us to clearly delineate the differences
  //     via documentation, but if we have this situation a lot, it could be
  //     confusing.
  //   * Add another field to Stage to allow registration on (newfield,
  //     type_url) instead of just type_url.
  //
  // Looking at WorkNode, there are definitely multiple executor types which
  // accept the same arguments in WorkParameters, but these could be represented
  // by adding a new field to WorkParameters. There is also the PARTIAL_RERUN
  // executor type which is used when duplicating WorkNodes, but this seems like
  // it will be handled differently with Checks (i.e. Checks of the same options
  // would be added, and new Results of the cached results would be added. There
  // wouldn't be a need to add placeholder Stages into such a graph). There
  // are also some executor types which serve as a way to separate ACLs, but
  // we expect this to be handled by realms.
  optional Value args = 4 [(google.api.field_behavior) = IMMUTABLE];

  // The version of this Stage.
  //
  // Updated any time fields in this Stage change, which includes all changes to
  // the active Stage Attempt (if state is ATTEMPTING).
  optional Revision version = 5 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The current state of the Stage.
  optional StageState state = 6 [(google.api.field_behavior) = OUTPUT_ONLY];

  // StateHistoryEntry records the database revision (commit timestamp) when
  // each time this Stage's state changes.
  message StateHistoryEntry {
    // The changed state.
    optional StageState state = 1;
    // The revision when the state change happens.
    optional Revision version = 2;
  }

  // Append-only list of StateHistoryEntry to record the database revision
  // (commit timestamp) when each time this Stage's state changes.
  repeated StateHistoryEntry state_history = 7 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Dependencies on other objects in the graph.
  //
  // Stages are allowed to depend on other Checks and Stages, and will not be
  // sent to an Executor until dependencies is resolved.
  //
  // Once the Stage is ATTEMPTING, this field is immutable.
  optional Dependencies dependencies = 8 [
    (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
    (turboci).id.allowed = IDENTIFIER_KIND_STAGE
  ];

  // ExecutionPolicyState is the set of execution policies which define the
  // overall execution policy for this Stage.
  //
  // `requested` is set by the stage creator. This is validated and augmented by
  // the Executor to become the `validated` policy.
  //
  // In the future, this may also include a `dynamic` policy which could allow
  // additional restrictions to be added after the Stage is created.
  message ExecutionPolicyState {
    // Requested execution policy is the policy which is set by the creator of
    // this Stage.
    //
    // This will be validated by the Executor prior to the Stage being committed
    // to the graph.
    //
    // If omitted, the Executor will provide a full StageExecutionPolicy according to
    // its own logic/configuration.
    optional StageExecutionPolicy requested = 1 [(google.api.field_behavior) = IMMUTABLE];

    // Actual execution policy is the policy validated and returned by the
    // Executor when it accepts the Stage for insertion to the graph.
    //
    // This is the policy that TurboCI will use to drive Attempts for this
    // Stage.
    optional StageExecutionPolicy validated = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

    // TBD: Potentially allow a `dynamic` ExecutionPolicy which callers can use
    // to decrease the effective limits on this Stage.
    //
    // If this is done:
    //   * Stage type configuration should indicate that dynamic execution
    //   policy is supported.
    //   * TurboCI must ensure this dynamic policy only ever shrinks.
    //   * If the changes are on `attempt_execution_policy_template`, TurboCI
    //   will set the requested policy for the future attempts to this updated
    //   policy. But the current attempt will not be affected.
  }

  // Execution policy for this Stage.
  optional ExecutionPolicyState execution_policy = 9;

  // Attempt represents a single attempt to execute a Stage.
  //
  // Stages in the AWAITING state ALWAYS have an active Attempt, even before
  // the Orchestrator sends the first RPC to the Executor for this Stage.
  //
  // TBD: Pull this into its own top-level StageAttempt entity because it will
  // need to have its own state and lifecycle/transactions.
  //
  // Next ID: 9
  message Attempt {
    // The Stage Attempt's identifier.
    optional ids.v1.StageAttempt identifier = 1;

    // The version of this Attempt.
    //
    // Updated any time fields in this Attempt change.
    optional Revision version = 2;

    // The current state of this Attempt.
    optional StageAttemptState state = 3;

    // StateHistoryEntry records the database revision (commit timestamp) when
    // each time this Attempt's state changes.
    message StateHistoryEntry {
      // The changed state.
      optional StageAttemptState state = 1;
      // The revision when the state change happens.
      optional Revision version = 2;
    }

    // Append-only list of StateHistoryEntry to record the database revision
    // (commit timestamp) when each time this Attempt's state changes.
    repeated StateHistoryEntry state_history = 4 [(google.api.field_behavior) = OUTPUT_ONLY];

    // An opaque value provided by a Stage Attempt process (i.e. a single thread
    // of execution which is servicing this Stage Attempt) which is used to
    // ensure that a StageAttempt is idempotently assigned to at most one single
    // thread of execution globally.
    //
    // Consider the case where a task with a StageAttemptToken is dispatched to
    // a worker fleet and due to bugs/netsplits/solar flares/etc. the task ends
    // up on two different machines in the fleet, or in two different pubsub
    // handlers. Basically, two logical processes now have a StageAttemptToken,
    // and this Stage Attempt is in the SCHEDULED state.
    //
    // The first thing all of these copycat processes should do is a WriteNodes
    // RPC where they attempt to set `process_uid` to a value *unique to that
    // worker thread*, and transition the state to RUNNING. One of these
    // processes will succeed, and the Stage Attempt will transition to RUNNING.
    // All the other processes will fail, and the returned error will have
    // a gRPC Status detail of StageAttemptClaimedFailure.
    //
    // The Orchestrator service will only permit this field to be set while the
    // Stage Attempt is PENDING or SCHEDULED. In the case of network failure,
    // multiple calls of `WriteNodes(token, current={RUNNING, <process_uid>})`
    // with the same process_uid will all succeed. However, the other worker
    // threads will produce different process_uid values, and the server will
    // reject their attempt to transition to the RUNNING state, and they should
    // drop the task.
    //
    // There is no specific form for process_uid, but it must be unique per
    // thread consuming this Stage Attempt. Examples:
    //   * A UUID
    //   * hostname:process_id:thread_id
    //   * servicename:unique_assigned_process_name
    //
    // In the event that this accepting thread crashes, it is expected that this
    // Stage Attempt will become INCOMPLETE on heartbeat timeout, and, retries
    // permitting, a new Stage Attempt will be generated.
    optional string process_uid = 5;

    // Details provided by the Executor about this Stage Attempt.
    //
    // This field is effectively an append-only map. The Executor and/or Stage
    // Attempt can only write data *of a given type* ONCE to this field, and
    // that data type must be unique within this field. If you need to add data
    // here multiple times during the lifecycle of the attempt, use different
    // types for each stage of that lifecycle.
    //
    // It can be updated by the Executor or Stage Attempt as long as the Stage
    // Attempt is not final (i.e. a state prior to COMPLETE or INCOMPLETE).
    //
    // Kept sorted by, and unique on, type_url.
    repeated Value details = 6;

    // Attempt-specific progress information.
    //
    // Note that the Edit log also has a Reason for every graph write - this
    // Progress message should be used when the Executor wants e.g. the UI to be
    // able to load just the current state of a Stage and display this
    // information in a time-oriented way.
    message Progress {
      // Low-effort/human-readable progress information.
      optional string msg = 1;

      // The version of this Stage which added this Progress message.
      optional Revision version = 2;

      // Machine-readable details for this progress item.
      //
      // Kept sorted by, and unique on, type_url.
      repeated Value details = 3;
    }
    // Append-only Executor-specefic progress messages.
    repeated Progress progress = 7;

    // Actual execution policy for this StageAttempt.
    //
    // When the orchestrator sends this attempt to the executor to run, the
    // executor will reevaluate the previous validated attempt execution
    // template in stage execution policy and make adjustments when necessary.
    // The validated execution policy is sent to the Orchestrator as part of
    // CurrentStageWrite when the executor advances the StageAttempt state
    // PENDING -> (SCHEDULED|RUNNING).
    optional StageAttemptExecutionPolicy execution_policy = 8;
  }
  // Current retry/attempts state of this Stage, stored in ascending order by
  // created time.
  //
  // Only the most recent attempt (the last in the list) is potentially 'live'.
  repeated Attempt attempts = 10 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Assignment describes the workflow's intent that this Stage will handle one
  // or more Checks in some fashion.
  message Assignment {
    // The Check that this Stage should handle.
    optional ids.v1.Check target = 1;

    // The expected state of the Check when this Stage is FINAL.
    //
    // NOTE: The Stage may, during its execution, create additional Stages with
    // this same Assignment as a way of propagating the responsibility of
    // handling the Check to those Stages.
    //
    // The Orchestrator will automatically advance the state of this Check to
    // the goal state when no more Stages are assigned to handle it with this
    // goal state.
    //
    // Ex. If some stage S is assigned a Check C with goal state PLANNED, it
    // indicates that S is responsible for ensuring that C is fully PLANNED. S
    // could spawn some helpers (S' and S'') with this same Assignment. Assuming
    // that S' and S'' don't further propagate the responsibility of handling C,
    // when all of S, S', and S'' are FINAL, the Orchestrator will advance C to
    // the PLANNED state.
    //
    // If a stage manually advances a Check to a state equal to or beyond the
    // goal state, then the Orchestrator will stop monitoring Assignments for
    // this Check at this goal state.
    //
    // Manual advancement can be dangerous if done when other Stages are still
    // operating on the Check at the earlier state (for example, if one Stage
    // moves a Check to PLANNED while another Stage is still trying to write to
    // the Check options, the writing Stage will fail to write out the options).
    optional CheckState goal_state = 2;
  }
  // The workflow's intent for this Stage.
  repeated Assignment assignments = 11 [(google.api.field_behavior) = IMMUTABLE];

  // A set of dependencies edges o Stages whose resolution should be treated as
  // a logical part of this Stage.
  //
  // Stages included in this continuation_group MUST be created BY THIS STAGE.
  //
  // If non-empty, this Stage will enter the state AWAITING_GROUP after the
  // final attempt. The orchestrator will move this Stage to the FINAL state
  // once these Dependencies are resolved. If this is empty, the Stage will move
  // directly from ATTEMPTING to FINAL.
  //
  // This allows for encapsulation of work where one Stage may spawn a group of
  // Stages which should be treated as a single unit - otherwise all waiters for
  // this Stage would need to be directly informed of, and wait for, these new
  // Stages, which introduces a leaky abstraction.
  //
  // If needed, this could be expanded to allow Checks later.
  optional Dependencies continuation_group = 12 [(turboci).id.allowed = IDENTIFIER_KIND_STAGE];
}

// StageAttemptClaimedFailure is a gRPC error detail message returned by
// WriteNodes when attempting to transition a Stage Attempt from
// PENDING/SCHEDULED to RUNNING with a mismatched process_uid.
//
// If your client receives an rpc status with this message in it, it means that
// another process already claimed this Stage Attempt, and you should stop
// attempting to execute this Stage Attempt.
message StageAttemptClaimedFailure {
  // The recorded Stage Attempt process_uid - this should only be used for
  // logging/reporting purposes (typically to help wayward developers see which
  // other process is *actually* working on this Stage Attempt).
  optional string claimed_by_process_uid = 1;
}
