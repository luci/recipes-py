// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/actor.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/dependencies.proto";
import "turboci/graph/orchestrator/v1/edit.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/omit_reason.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_state.proto";
import "turboci/graph/orchestrator/v1/stage_concluded_reason.proto";
import "turboci/graph/orchestrator/v1/stage_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_state.proto";
import "turboci/graph/orchestrator/v1/value_ref.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// A Stage is an executable node in the workflow.
//
// The Orchestrator will coordinate with the Executor which is registered to
// match `args.type_url` to actually run the Stage.
//
// See also:
//   * Identifier.Stage* (Identifiers for Stages, StageAttempts, etc.)
//
// Next ID: 17
message Stage {
  // The Stage's identifier.
  optional ids.v1.Stage identifier = 1 [(google.api.field_behavior) = IMMUTABLE];

  // If set, the reason this Stage's content was omitted. Only UNKNOWN (default
  // value, used when the content was included) and PLACEHOLDER are valid for a
  // Stage, since Stages that were unwanted or inaccessible will be removed from
  // the WorkPlan entirely.
  //
  // A few fields may be populated even if `omit_reason` is set:
  //   * `identifier` will always be populated.
  //   * `edits` may be populated.
  optional OmitReason omit_reason = 15;

  // Actor which created the Stage.
  optional Actor created_by = 2 [(google.api.field_behavior) = IMMUTABLE];

  // The security realm for this Stage.
  //
  // When a Stage inserts another, the inserted Stage will inherit the realm of
  // the inserting Stage, unless this is explicitly set.
  optional string realm = 3 [(google.api.field_behavior) = IMMUTABLE];

  // The arguments of the Stage.
  //
  // The type of this ValueRef must be pre-registered with the Orchestrator,
  // and that registration will indicate which Executor should handle this
  // Stage.
  //
  // NOTE: It's assumed that args.type_url will be a sufficient routing key to
  // the various registered Executors, but it's POSSIBLE that we may need to
  // have multiple Executors handle exactly the same Stage type, at which point
  // we would need to either:
  //   * Add a secondary type to distinguish them; this would have the
  //     additional benefit of allowing us to clearly delineate the differences
  //     via documentation, but if we have this situation a lot, it could be
  //     confusing.
  //   * Add another field to Stage to allow registration on (newfield,
  //     type_url) instead of just type_url.
  //
  // Looking at WorkNode, there are definitely multiple executor types which
  // accept the same arguments in WorkParameters, but these could be
  // represented by adding a new field to WorkParameters. There is also the
  // PARTIAL_RERUN executor type which is used when duplicating WorkNodes, but
  // this seems like it will be handled differently with Checks (i.e. Checks of
  // the same options would be added, and new Results of the cached results
  // would be added. There wouldn't be a need to add placeholder Stages into
  // such a graph). There are also some executor types which serve as a way to
  // separate ACLs, but we expect this to be handled by realms.
  optional ValueRef args = 4 [(google.api.field_behavior) = IMMUTABLE];

  // The version of this Stage.
  //
  // Updated any time fields in this Stage change, which includes all changes to
  // the active Stage Attempt (if state is ATTEMPTING).
  optional Revision version = 5;

  // The current state of the Stage.
  optional StageState state = 6;

  // If this stage was cancelled, this indicates the Actor which cancelled
  // it.
  optional Actor cancelled_by = 14;

  // StateHistoryEntry records the database revision (commit timestamp) when
  // each time this Stage's state changes.
  message StateHistoryEntry {
    // The changed state.
    optional StageState state = 1 [(google.api.field_behavior) = IMMUTABLE];
    // The revision when the state change happens.
    optional Revision version = 2 [(google.api.field_behavior) = IMMUTABLE];
  }

  // Append-only list of StateHistoryEntry to record the database revision
  // (commit timestamp) when each time this Stage's state changes.
  repeated StateHistoryEntry state_history = 7;

  // Dependencies on other objects in the graph.
  //
  // Stages are allowed to depend on other Checks and Stages.
  //
  // All dependencies must be specified at once when the stage is
  // inserted (unlike Check dependencies, which can be built incrementally via
  // multiple WriteNodes calls). The Orchestrator will start tracking their
  // resolution right away. In particular, if all dependencies are already
  // resolved when the stage is inserted, it will appear in ATTEMPTING state
  // right away. Otherwise it will be inserted in PLANNED state and the
  // Orchestrator will move it into ATTEMPTING state at a later time, when
  // dependencies are resolved.
  optional Dependencies dependencies = 8 [
    (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
    (turboci).id.allowed = IDENTIFIER_KIND_STAGE
  ];

  // ExecutionPolicyState is the set of execution policies which define the
  // overall execution policy for this Stage.
  //
  // `requested` is set by the stage creator. This is validated and augmented by
  // the Executor to become the `validated` policy.
  //
  // In the future, this may also include a `dynamic` policy which could allow
  // additional restrictions to be added after the Stage is created.
  message ExecutionPolicyState {
    // Requested execution policy is the policy which is set by the creator of
    // this Stage.
    //
    // This will be validated by the Executor prior to the Stage being committed
    // to the graph.
    //
    // If omitted, the Executor will provide a full StageExecutionPolicy according to
    // its own logic/configuration.
    optional StageExecutionPolicy requested = 1 [(google.api.field_behavior) = IMMUTABLE];

    // Actual execution policy is the policy validated and returned by the
    // Executor when it accepts the Stage for insertion to the graph.
    //
    // This is the policy that TurboCI will use to drive Attempts for this
    // Stage.
    optional StageExecutionPolicy validated = 2;

    // TBD: Potentially allow a `dynamic` ExecutionPolicy which callers can use
    // to decrease the effective limits on this Stage.
    //
    // If this is done:
    //   * Stage type configuration should indicate that dynamic execution
    //   policy is supported.
    //   * TurboCI must ensure this dynamic policy only ever shrinks.
    //   * If the changes are on `attempt_execution_policy_template`, TurboCI
    //   will set the requested policy for the future attempts to this updated
    //   policy. But the current attempt will not be affected.
  }

  // Execution policy for this Stage.
  optional ExecutionPolicyState execution_policy = 9;

  // Attempt represents a single attempt to execute a Stage.
  //
  // Stages in the AWAITING state ALWAYS have an active Attempt, even before
  // the Orchestrator sends the first RPC to the Executor for this Stage.
  //
  // TBD: Pull this into its own top-level StageAttempt entity because it will
  // need to have its own state and lifecycle/transactions.
  //
  // Next ID: 15
  message Attempt {
    // The Stage Attempt's identifier.
    optional ids.v1.StageAttempt identifier = 1 [(google.api.field_behavior) = IMMUTABLE];

    // If set, the reason this Attempt's content was omitted. Only UNKNOWN
    // (default value, used when the content was included) and PLACEHOLDER are
    // valid for an Attempt, since Attempts that were unwanted or inaccessible
    // will be removed from the WorkPlan entirely.
    //
    // A few fields may be populated even if `omit_reason` is set:
    //   * `identifier` will always be populated.
    optional OmitReason omit_reason = 14;

    // The version of this Attempt.
    //
    // Updated any time fields in this Attempt change.
    optional Revision version = 2;

    // Last time we got a WriteNodes from this Attempt with the `current_stage`
    // field populated.
    //
    // This is distinct from `version` because the state of the Attempt can be
    // altered by the Orchestrator without counting as a heartbeat.
    //
    // Until the first successful WriteNodes call from the executor happens,
    // this will remain unset. This will be set, but not updated, during
    // THROTTLED (because we accepted a WriteNodes in order to enter the
    // THROTTLED state).
    optional Revision last_heartbeat = 10;

    // The current state of this Attempt.
    optional StageAttemptState state = 3;

    // StateHistoryEntry records the database revision (commit timestamp) when
    // each time this Attempt's state changes.
    message StateHistoryEntry {
      // The changed state.
      optional StageAttemptState state = 1 [(google.api.field_behavior) = IMMUTABLE];
      // The revision when the state change happens.
      optional Revision version = 2 [(google.api.field_behavior) = IMMUTABLE];
    }

    // Append-only list of StateHistoryEntry to record the database revision
    // (commit timestamp) when each time this Attempt's state changes.
    repeated StateHistoryEntry state_history = 4;

    // If set, this Attempt is in a state where the Orchestrator is waiting for
    // some future time to interact with it.
    //
    // The states where this is set are:
    //
    //   * PENDING - The Orchestrator attempted to send this Stage Attempt to
    //     the executor, but failed for some reason. The Orchestrator will try
    //     again after this time.
    //   * THROTTLED - The Executor explicitly asked the Orchestrator to hold
    //     a PENDING attempt until later. The Orchestrator not to attempt to
    //     call RunStage again until this time.
    //   * AWAITING_RETRY - This Attempt was created as a retry of a previous
    //     INCOMPLETE attempt, and the Orchestrator will not advance it to
    //     PENDING until this time.
    //
    // In all other states, this field is unset.
    optional google.protobuf.Timestamp waiting_until = 11;

    // An opaque value provided by a Stage Attempt process (i.e. a single thread
    // of execution which is servicing this Stage Attempt) which is used to
    // ensure that a StageAttempt is idempotently assigned to at most one single
    // thread of execution globally.
    //
    // Consider the case where a task with a StageAttemptToken is dispatched to
    // a worker fleet and due to bugs/netsplits/solar flares/etc. the task ends
    // up on two different machines in the fleet, or in two different pubsub
    // handlers. Basically, two logical processes now have a StageAttemptToken,
    // and this Stage Attempt is in the SCHEDULED state.
    //
    // The first thing all of these copycat processes should do is a WriteNodes
    // RPC where they attempt to set `process_uid` to a value *unique to that
    // worker thread*, and transition the state to RUNNING. One of these
    // processes will succeed, and the Stage Attempt will transition to RUNNING.
    // All the other processes will fail, and the returned error will have
    // a gRPC Status detail of StageAttemptClaimedFailure.
    //
    // The Orchestrator service will only permit this field to be set while the
    // Stage Attempt is PENDING or SCHEDULED. In the case of network failure,
    // multiple calls of `WriteNodes(token, current={RUNNING, <process_uid>})`
    // with the same process_uid will all succeed. However, the other worker
    // threads will produce different process_uid values, and the server will
    // reject their attempt to transition to the RUNNING state, and they should
    // drop the task.
    //
    // There is no specific form for process_uid, but it must be unique per
    // thread consuming this Stage Attempt. Examples:
    //   * A UUID
    //   * hostname:process_id:thread_id
    //   * servicename:unique_assigned_process_name
    //
    // In the event that this accepting thread crashes, it is expected that this
    // Stage Attempt will become INCOMPLETE on heartbeat timeout, and, retries
    // permitting, a new Stage Attempt will be generated.
    optional string process_uid = 5;

    // Details provided by the Executor about this Stage Attempt.
    //
    // This may only be written once per data type.
    //
    // If a CurrentAttemptWrite would overwrite a detail with a different value,
    // a Progress message with ProgressIgnoredDetail will be added
    // to the Attempt instead.
    //
    // It can be updated by the Executor or Stage Attempt as long as the Stage
    // Attempt is not final (i.e. a state prior to COMPLETE or INCOMPLETE).
    //
    // Kept sorted by, and unique on, type_url.
    repeated ValueRef details = 6;

    // Attempt-specific progress information.
    //
    // Note that the Edit log also has a Reason for every graph write - this
    // Progress message should be used when the Executor wants e.g. the UI to be
    // able to load just the current state of a Stage and display this
    // information in a time-oriented way.
    message Progress {
      // Low-effort/human-readable progress information.
      optional string message = 1;

      // The version of the Stage Attempt when this Progress message was added.
      optional Revision version = 2;

      // Machine-readable details for this progress item.
      //
      // Kept sorted by, and unique on, type_url.
      repeated ValueRef details = 3;

      // The entity which created this progress message.
      //
      // If created_by is Orchestrator, then `details` may contain the
      // following:
      //   * turboci.graph.orchestrator.v1.ProgressEvolvePending
      //   * turboci.graph.orchestrator.v1.ProgressIgnoredDetail
      optional Actor created_by = 4;

      // Unique-to-this-Attempt key for this Progress message.
      //
      // Used to prevent duplicate Progress messages via WriteNodesRequest.
      //
      // See WriteNodesRequest.StageAttemptProgress.
      optional string idempotency_key = 5;
    }
    // Append-only Executor-specefic progress messages.
    repeated Progress progress = 7;

    // Actual execution policy for this StageAttempt.
    //
    // When the orchestrator sends this attempt to the executor to run, the
    // executor will reevaluate the previous validated attempt execution
    // template in stage execution policy and make adjustments when necessary.
    // The validated execution policy is sent to the Orchestrator as part of
    // CurrentAttemptWrite when the executor advances the StageAttempt state
    // PENDING -> (SCHEDULED|RUNNING).
    optional StageAttemptExecutionPolicy execution_policy = 8;
  }
  // Current retry/attempts state of this Stage, stored in ascending order by
  // created time.
  //
  // Only the most recent attempt (the last in the list) is potentially 'live'.
  //
  // Note that the revision of the attempts are unrelated to the revision of the
  // Stage. While the Stage is ATTEMPTING, the Stage's revision only changes
  // when:
  //   * A new Attempt is created
  //   * The Stage is canceled
  repeated Attempt attempts = 10;

  // Assignment describes the workflow's intent that this Stage will handle one
  // or more Checks in some fashion.
  message Assignment {
    // The Check that this Stage should handle.
    optional ids.v1.Check target = 1;

    // The expected state of the Check when this Stage is FINAL.
    //
    // NOTE: The Stage may, during its execution, create additional Stages with
    // this same Assignment as a way of propagating the responsibility of
    // handling the Check to those Stages.
    //
    // The Orchestrator will automatically advance the state of this Check to
    // the goal state when no more Stages are assigned to handle it with this
    // goal state.
    //
    // Ex. If some stage S is assigned a Check C with goal state PLANNED, it
    // indicates that S is responsible for ensuring that C is fully PLANNED. S
    // could spawn some helpers (S' and S'') with this same Assignment. Assuming
    // that S' and S'' don't further propagate the responsibility of handling C,
    // when all of S, S', and S'' are FINAL, the Orchestrator will advance C to
    // the PLANNED state.
    //
    // If a stage manually advances a Check to a state equal to or beyond the
    // goal state, then the Orchestrator will stop monitoring Assignments for
    // this Check at this goal state.
    //
    // Manual advancement can be dangerous if done when other Stages are still
    // operating on the Check at the earlier state (for example, if one Stage
    // moves a Check to PLANNED while another Stage is still trying to write to
    // the Check options, the writing Stage will fail to write out the options).
    optional CheckState goal_state = 2;
  }
  // The workflow's intent for this Stage.
  repeated Assignment assignments = 11 [(google.api.field_behavior) = IMMUTABLE];

  // A set of dependencies edges to Stages whose resolution should be treated as
  // a logical part of this Stage.
  //
  // Stages included in this continuation_group MUST be created BY THIS STAGE.
  //
  // If non-empty, this Stage will enter the state AWAITING_GROUP after the
  // final attempt. The orchestrator will move this Stage to the FINAL state
  // once these Dependencies are resolved. If this is empty, the Stage will move
  // directly from ATTEMPTING to FINAL.
  //
  // This allows for encapsulation of work where one Stage may spawn a group of
  // Stages which should be treated as a single unit - otherwise all waiters for
  // this Stage would need to be directly informed of, and wait for, these new
  // Stages, which introduces a leaky abstraction.
  //
  // These dependencies are mutable as long as the stage is in ATTEMPTING state.
  optional Dependencies continuation_group = 12 [(turboci).id.allowed = IDENTIFIER_KIND_STAGE];

  // Describes why this stage is not PLANNED or ATTEMPTING anymore.
  //
  // Set for stages that are in AWAITING_GROUP or FINAL states.
  optional StageConcludedReason concluded_reason = 13;

  // StageEdits for this Stage.
  //
  // Sorted ascending by `version`.
  repeated Edit edits = 16;
}

// StageAttemptClaimedFailure is a gRPC error detail message returned by
// WriteNodes when attempting to transition a Stage Attempt from
// PENDING/SCHEDULED to RUNNING with a mismatched process_uid.
//
// If your client receives an rpc status with this message in it, it means that
// another process already claimed this Stage Attempt, and you should stop
// attempting to execute this Stage Attempt.
message StageAttemptClaimedFailure {
  // The recorded Stage Attempt process_uid - this should only be used for
  // logging/reporting purposes (typically to help wayward developers see which
  // other process is *actually* working on this Stage Attempt).
  optional string claimed_by_process_uid = 1;
}

// StageAttemptCurrentState is returned in QueryNodesResponse,
// WriteNodesResponse, and also embedded in errors returned by these RPCs.
//
// This will always be present when a properly encoded Stage Attempt token is
// used with those RPCs (even when that token refers to a now-final Stage
// Attempt).
message StageAttemptCurrentState {
  // The state of the stage attempt which corresponds to the token provided
  // in the WriteNodesRequest.
  //
  // NOTE: This is authoritative, and could be in a state which is later than
  // the one that the client which made the RPC expects.
  //
  //   * CANCELLING - The Stage has been cancelled, but there has not yet been
  //     a heartbeat from the the Stage Attempt. As soon as there is a
  //     current_stage write from the Stage Attempt, this state will turn into
  //     TEARING_DOWN.
  //   * TEARING_DOWN - The Stage was cancelled while a Stage Attempt was
  //     RUNNING. When a WriteNodes with current_stage set happens, the
  //     orchestrator will transition to TEARING_DOWN in that same
  //     transaction and report this state here. The still-running attempt
  //     should do any graceful shutdown it can before
  //     `current_state_deadline` and then do a WriteNodes to mark the
  //     current attempt as either COMPLETE or INCOMPLETE.
  //   * COMPLETE/INCOMPLETE - Something already marked this attempt as
  //     finished. The still-running attempt should immediately shutdown
  //     without attempting to do any further QueryNodes/WriteNodes calls.
  //     Note that this could happen if a Stage is cancelled while PENDING or
  //     SCHEDULED.
  optional StageAttemptState state = 1;

  // The version of the Stage Attempt that the orchestrator observed.
  optional Revision version = 2;

  // If set, the timestamp for when the orchestrator will timeout the current
  // state.
  optional google.protobuf.Timestamp update_state_by = 3;

  // If set, the timestamp for when the orchestrator expects the next
  // heartbeat.
  optional google.protobuf.Timestamp heartbeat_by = 4;
}
