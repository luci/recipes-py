// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/check_kind.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision_range.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Query describes a simple graph query.
//
// This is composed of three phases: selection, expansion and collection.
//
// The selection phase queries for a set of nodes within a WorkPlan
// - effectively a regular SELECT type query on a traditional database.
//
// After the selection phase, the expansion phase allows traversal along the
// edges of the selected nodes. Currently only 'dependency' edge traversal is
// supported, but other types of relationships could be possible in the future
// (e.g. 'created_by', 'written_by', etc.).
//
// Finally, after the set of nodes has been fully expanded, we collect all the
// requested data from those Nodes.
//
// See QueryNodesRequest.version for how this Query interacts with transactions.
message Query {
  // Type URLs (for Check Option Datum, Check Result Datum, Stage args,
  // CheckEdit Option Datum and CheckEdit Result) that the caller wants to see
  // in the response.  Any child Node whose type URL is not specified here
  // will be omitted in the response.
  //
  // TBD: The special value "*" means that the caller wants to see all type
  // URLs, but this requires an extra permission. Extra permission is needed
  // to encourage clients to be explicit about what they want to reduce
  // bandwidth, coupling and increase auditability.
  repeated string type_urls = 1;

  // Select picks some set of nodes out of the graph.
  message Select {
    // How this selection of nodes should be constrained to one or more
    // WorkPlans.
    message WorkPlanConstraint {
      // Constrain this Select to the given WorkPlan(s).
      repeated ids.v1.WorkPlan in_workplans = 1;

      // TBD: criteria to query across workplans - presumably recent ones, but
      // also probably this should allow constraining to specific templated
      // workflows.
      //
      // IIUC node_class is kind of equivalent to such a filter, except it's
      // duplicated to each WorkNode, not a property of WorkPlan.
    }
    // Which WorkPlans to search across.
    optional WorkPlanConstraint workplan = 1;

    // The identifiers of specific nodes to select.
    //
    // This should be used if you already know the identifiers of the nodes you
    // care about.
    repeated ids.v1.Identifier nodes = 2 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE
      // TBD: Allow additional identifier kinds here.
    ];

    // Select one or more Checks which match this pattern.
    message CheckPattern {
      // Find Checks of this kind (unset means all kinds).
      optional CheckKind kind = 1;

      // Find Checks whose `Identifier.Check.id` matches this re2 regex.
      optional string id_regex = 2;

      // Find Checks with *any* of these options. Note that you still must set
      // type_urls and collect.data.check.options to actually get the
      // Check Option data in the result set.
      repeated string with_option_types = 3;

      // Find Checks in this state.
      optional CheckState state = 4;

      // Find Checks with *any* of these result data types. Note that you still
      // must set type_urls and collect.data.check.result_data to actually get the
      // Check Result data in the result set.
      repeated string with_result_data_types = 5;
    }
    // Select Checks matching these patterns.
    repeated CheckPattern check_patterns = 3;

    // Select one or more Stages which match this pattern.
    message StagePattern {
      // TBD
    }

    // Select Stages matching these patterns.
    repeated StagePattern stage_patterns = 4;
  }
  // Select an arbitrary set of nodes.
  optional Select select = 2;

  // Expand takes the selected node set and 'expands' it by following edges in
  // the graph from those nodes.
  message Expand {
    // How to follow Check.dependencies and Stage.dependencies.
    message Dependencies {
      // Follow this many dependents (so for some node X, follow to other
      // nodes which depend-on X up to this distance away).
      //
      // 0 means "do not follow dependents".
      //
      // Must be >= 0.
      optional int32 dependents_depth = 1;

      // Follow this many dependencies (so for some node, follow it's
      // `dependencies` fields up to this distance away).
      //
      // 0 means "do not follow dependencies".
      //
      // Must be >= 0.
      optional int32 dependencies_depth = 2;

      // If unset, includes ALL edges, regardless of resolution. Implies
      // `current = true`.
      //
      // If True, only includes resolved, satisfied, edges.
      // If False, only includes resolved, unsatisfied, edges.
      //
      // See the documentation on `EdgeGroup.resolution`.
      optional bool satisfied = 3;

      // If true, ignores the `resolution` field of the node's EdgeGroups.
      //
      // If false (or unset), only follows edges to nodes which have the
      // `resolution` field set.
      //
      // For example:
      //
      //   A -> {B, C, threshold=1}
      //
      //   A->B becomes resolved, and A moves to WAITING. A will forever show
      //   a resolution on B, but not on C.
      //
      //   If A->C later resolves (e.g. C becomes FINAL), and a stage wants to
      //   find "ALL resolved dependencies of A", it would do this query with
      //   `current=true`. If the stage only wants "Dependencies of A which were
      //   the set that actually unblocked A", then it would do this query with
      //   `current=false`.
      optional bool current = 4;

      // TBD: Other selection criteria (e.g. only checks of kind X or with
      // option type Y)
    }
    // Instructs the query to follow dependencies of the selected node(s).
    optional Dependencies dependencies = 1;

    // TBD: Other edge types, such as created_by or written_by.
  }
  // Expand that set of nodes by following their edges.
  optional Expand expand = 3;

  // Collect retrieves data from the expanded node set.
  message Collect {
    // Describes what data the caller wants to see for Checks.
    message Check {
      // Include CheckOptions filtered by `type_urls` for any selected Checks.
      optional bool options = 1;

      // Include Result data filtered by `type_urls` for any selected Checks.
      optional bool result_data = 2;

      // Include edits only within this range of Revisions.
      //
      // An empty RevisionRange (e.g. {0, 0}) means `all edits`.
      optional RevisionRange edits = 3;
    }
    // Describes what data the caller wants to see for Checks.
    optional Check check = 1;

    // Describes what data the caller wants to see for Stages.
    message Stage {
      // TBD: what attempt progress data to include (and maybe for which
      // attempt(s) to include it).

      // Include edits only within this range of Revisions.
      //
      // An empty RevisionRange (e.g. {0, 0}) means `all edits`.
      optional RevisionRange edits = 1;
    }
    // Describes what data the caller wants to see for Stages.
    optional Stage stage = 2;
  }
  // The data to collect from the expanded node set.
  optional Collect collect = 4;
}
