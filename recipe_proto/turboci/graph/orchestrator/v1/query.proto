// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/check_kind.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision_range.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// When expanding a query selection set with Query.Expand.Dependencies or
// Query.Expand.Dependants, how should we actually expand that set?
enum QueryExpandDepsMode {
  // Unknown query expansion mode.
  //
  // Defaults to 'REQUESTED'.
  QUERY_EXPAND_DEPS_MODE_UNKNOWN = 0;

  // Expand to deps which are listed in dependencies.edges.
  QUERY_EXPAND_DEPS_MODE_EDGES = 1;

  // Expand to deps which are listed (transitively) in dependencies.satisfied.
  //
  // Note that this will be the empty set for nodes which are not already past
  // the PLANNED state, and for nodes which have unsatisfiable dependencies.
  QUERY_EXPAND_DEPS_MODE_SATISFIED = 2;
}

// Query describes a simple graph query.
//
// This is composed of three phases: selection, expansion and collection.
//
// The selection phase queries for a set of nodes within a WorkPlan
// - effectively a regular SELECT type query on a traditional database.
//
// After the selection phase, the expansion phase allows traversal along the
// edges of the selected nodes. Currently only 'dependency' edge traversal is
// supported, but other types of relationships could be possible in the future
// (e.g. 'created_by', 'written_by', etc.).
//
// Finally, after the set of nodes has been fully expanded, we collect all the
// requested data from those Nodes.
//
// See QueryNodesRequest.version for how this Query interacts with transactions.
message Query {
  // Type URLs (for Check Option Datum, Check Result Datum, Stage args,
  // CheckEdit Option Datum and CheckEdit Result) that the caller wants to see
  // in the response.  Any child Node whose type URL is not specified here
  // will be omitted in the response.
  //
  // TBD: The special value "*" means that the caller wants to see all type
  // URLs, but this requires an extra permission. Extra permission is needed
  // to encourage clients to be explicit about what they want to reduce
  // bandwidth, coupling and increase auditability.
  //
  // TBD: Allow limited wildcards to include everything under some package
  // namespace.
  repeated string type_urls = 1;

  // Select picks some set of nodes out of the graph.
  message Select {
    // How this selection of nodes should be constrained to one or more
    // WorkPlans.
    message WorkPlanConstraint {
      // Constrain this Select to the given WorkPlan(s).
      repeated ids.v1.WorkPlan in_workplans = 1;

      // TBD: criteria to query across workplans - presumably recent ones, but
      // also probably this should allow constraining to specific templated
      // workflows.
      //
      // IIUC node_class is kind of equivalent to such a filter, except it's
      // duplicated to each WorkNode, not a property of WorkPlan.
    }
    // Which WorkPlans to search across.
    optional WorkPlanConstraint workplan = 1;

    // The identifiers of specific nodes to select.
    //
    // This should be used if you already know the identifiers of the nodes you
    // care about.
    repeated ids.v1.Identifier nodes = 2 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE
      // TBD: Allow additional identifier kinds here.
    ];

    // Select one or more Checks which match this pattern.
    message CheckPattern {
      // Find Checks of this kind (unset means all kinds).
      optional CheckKind kind = 1;

      // Find Checks whose `Identifier.Check.id` matches this re2 regex.
      optional string id_regex = 2;

      // Find Checks with *any* of these options. Note that you still must set
      // type_urls and collect.data.check.options to actually get the
      // Check Option data in the result set.
      repeated string with_option_types = 3;

      // Find Checks in this state.
      optional CheckState state = 4;

      // Find Checks with *any* of these result data types. Note that you still
      // must set type_urls and collect.data.check.result_data to actually get the
      // Check Result data in the result set.
      repeated string with_result_data_types = 5;
    }
    // Select Checks matching these patterns.
    repeated CheckPattern check_patterns = 3;

    // Select one or more Stages which match this pattern.
    message StagePattern {
      // TBD
    }

    // Select Stages matching these patterns.
    repeated StagePattern stage_patterns = 4;
  }
  // Select an arbitrary set of nodes.
  optional Select select = 2;

  // Expand takes the selected node set and 'expands' it by following edges in
  // the graph from those nodes.
  message Expand {
    // How to expand the dependencies for a Check or Stage.
    message Dependencies {
      // How to expand dependencies.
      //
      // Defaults to QUERY_EXPAND_DEPS_MODE_EDGES.
      optional QueryExpandDepsMode mode = 1;

      // TBD: Allow walking more than one dependency down?
    }
    // For each selected Check or Stage, include its immediate dependencies.
    //
    // So given:
    //   A -> {B, C}
    //
    // (B, C) are dependencies of A.
    optional Dependencies dependencies = 1;

    // How to expand the dependents for a Check or Stage.
    message Dependents {
      // How to expand dependents.
      //
      // Defaults to QUERY_EXPAND_DEPS_MODE_EDGES.
      optional QueryExpandDepsMode mode = 1;

      // TBD: Allow walking more than one dependent up?
    }
    // For each selected Check or Stage, include any Checks/Stages which depend
    // on it.
    //
    // So given:
    //   A -> {B, C}
    //
    // A is a dependent of B.
    optional Dependents dependents = 2;

    // TBD: Other edge types, such as created_by or written_by?
    // If we include them, how would we indicate these relationships in GraphView?
    // We may need created_by/written_by as explicit fields in the various
    // nodes.
  }
  // Expand that set of nodes by following their edges.
  optional Expand expand = 3;

  // Collect retrieves data from the expanded node set.
  message Collect {
    // Describes what data the caller wants to see for Checks.
    message Check {
      // Include CheckOptions filtered by `type_urls` for any selected Checks.
      optional bool options = 1;

      // Include Result data filtered by `type_urls` for any selected Checks.
      optional bool result_data = 2;

      // Include edits only within this range of Revisions.
      //
      // An empty RevisionRange (e.g. {0, 0}) means `all edits`.
      optional RevisionRange edits = 3;
    }
    // Describes what data the caller wants to see for Checks.
    optional Check check = 1;

    // Describes what data the caller wants to see for Stages.
    message Stage {
      // TBD: what attempt progress data to include (and maybe for which
      // attempt(s) to include it).

      // Include edits only within this range of Revisions.
      //
      // An empty RevisionRange (e.g. {0, 0}) means `all edits`.
      optional RevisionRange edits = 1;
    }
    // Describes what data the caller wants to see for Stages.
    optional Stage stage = 2;
  }
  // The data to collect from the expanded node set.
  optional Collect collect = 4;
}
