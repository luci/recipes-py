// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/orchestrator/v1/query.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/type_set.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Request message for TurboCIGraphService.QueryNodes.
message QueryNodesRequest {
  // The token which indicates that the query is coming from within a specific
  // WorkPlan.
  //
  // A suitable token is provided to the Executor of a Stage or to the creator
  // of an empty Workplan.
  //
  // This is in addition to regular RPC authorization.
  //
  // If missing, this RPC will check that the caller additionally has the
  // 'turboci.workplans.readExternal' on the implied workplans.
  optional string token = 1;

  // TypeInfo lets the orchestrator know which auxiliary type(s) the caller
  // wants to see in Check Options, Check Results, Stage args, Edits, etc.
  message TypeInfo {
    // Set of type URLs that the caller wants to see in the response. Any child
    // Node whose type URL is not specified here will be omitted in the
    // response.
    //
    // The set may contain an URL with a trailing wildcard to indicate that you
    // want all data whose type appears in this proto namespace. For example:
    //   * type.googleapis.com/turboci.data.*
    //   * type.googleapis.com/*
    //
    // Use this power wisely! This can have the following adverse affects:
    //   * It can send your client much more data than it needs (and the server
    //     will do more work to obtain and serialize this useless data).
    //   * It can make coupling analysis harder; if all nodes are reading all
    //     data, then it makes it much harder to answer "who depends on this
    //     data type?"
    //
    // Good usages of this (especially the full wildcard, "*") include:
    //   * Humans trying to debug/observe data in the graph (via UI or CLI).
    //   * LLMs trying to analyze data in the graph.
    optional TypeSet wanted = 1;

    // If specified the orchestrator will encode all Values with this
    // alternate encoding, excluding types listed in `known`.
    //
    // Note that the orchestrator may have an out-of-date version of the
    // descriptors - if this happens then Value.has_unknown_fields may be set
    // to `true`.
    //
    // This is intended to support:
    //   * Humans trying to debug/observe data in the graph (via UI or CLI).
    //   * LLMs trying to analyze data in the graph.
    //
    // Stage implementations, monitoring pipelines and scripts should ideally
    // be written to directly use the original binary encoded proto data.
    optional bool unknown_jsonpb = 2;

    // Set of type URLs that the caller has descriptors for. Used with
    // `unknown_jsonpb` to avoid encoding types the caller does actually have
    // descriptors for.
    optional TypeSet known = 3;
  }
  // A description of the desired Value types this query should return.
  //
  // Only Value types listed by `wanted` will have their values in the response.
  //
  // Datum objects with unwanted type_urls will be omitted from the response.
  optional TypeInfo type_info = 2;

  // VersionRestriction describes how this query can be constrained by database
  // version.
  message VersionRestriction {
    // What type of restriction to apply.
    oneof restriction {
      // Require will cause the query to return the current version of all
      // nodes (from the read-only transaction), but it will check that all
      // queried nodes have a Revision less than or equal to this version.
      //
      // If QueryNodes would return a node newer than `require`, it will return
      // FAILED_PRECONDITION with a detail message of
      // TransactionConflictFailure.
      //
      // Use this when issuing follow-up queries within a transaction, where you
      // want to abort and retry that transaction as soon as you know there will
      // be a conflict.
      Revision require = 1;

      // Query from the database at this snapshot version.
      //
      // This can return data older than the current version in the database.
      //
      // Use this when trying to assemble a consistent (but possibly stale) view
      // of the data in the database.
      //
      // This CAN be used from a transaction (WriteNodes will eventually detect
      // the discrepancy and you will need to retry the transaction at that
      // point).
      Revision snapshot = 2;
    }
  }
  // If omitted, QueryNodes will return the current version of any nodes in the
  // query from within a read-only transaction.
  //
  // Otherwise, this restricts how the query interacts with the underlying
  // database.
  optional VersionRestriction version = 3;

  // One or more Queries to select nodes to return.
  repeated Query query = 4;
}
