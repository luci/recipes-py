// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/protobuf/duration.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// StageExecutionPolicy describes constraints on how a Stage may be executed
// by the Orchestrator.
message StageExecutionPolicy {
  // Retry describes the policy for retrying a Stage across multiple Attempts.
  message Retry {
    // The maximum number of retries (apart from the first attempt) that will be
    // made for this Stage.
    //
    // If an Attempt fails (i.e. becomes INCOMPLETE), a new Attempt is created
    // when all of the below is true:
    //   1. The new number of Attempts does not exceed max_retries+1. If this
    //      condition is violated, StageConcludedReason will be NO_RETRIES_LEFT.
    //   2. There's enough time left in `stage_timeout` to run the new attempt
    //      to completion in the most pessimistic case (waiting the attempt
    //      retry backoff timer and hitting all possible stage attempt timeouts
    //      configured in the StageAttemptExecutionPolicy). If this condition
    //      is violated, StageConcludedReason will be TIMEOUT.
    //   3. The last attempt had `WriteNodes.current_state.block_new_attempts`
    //      set to false. If this condition is violated, StageConcludedReason
    //      will be FINAL_ATTEMPT_BLOCKED_RETRY.
    //
    // If no retries are allowed, the stage will transition to FINAL or
    // AWAITING_GROUP state (in case the incomplete attempt managed to submit
    // a continuation group before it died).
    optional int32 max_retries = 1;

    // TBD: A way to control how TurboCI does backoff to the Executor - likely
    // it would be good enough to set this statically via Executor config. We
    // shouldn't have to worry too much about changing this config at runtime
    // because retry backoff calculation is effectively instantaneous (all
    // happens within a single transaction).

    // TBD: May be worth adding a way to control implicit retry criteria
    // ('only retry if $condition').
  }
  // Policy for retrying this Stage across multiple Attempts.
  //
  // If omitted, the Stage will be attempted at most once (if at all permitted
  // by `stage_timeout` and `execute_at_least_one_attempt`).
  optional Retry retry = 1;

  // An approximate cap on the maximum amount of time the Stage itself can stay
  // in a non-FINAL state.
  //
  // This timeout starts from the time the Stage is *created*.
  //
  // When launching an attempt, the orchestrator will estimate when the attempt
  // will finish executing in the most pessimistic scenario (e.g. hitting all
  // possible StageAttemptExecutionPolicy timeouts). A new attempt will be
  // allowed to run if its estimated completion time still fits within the stage
  // timeout. Retrying an attempt has extra conditions (see Retry for details).
  // If `execute_at_least_one_attempt` is true, then this timeout will be
  // totally ignored when launching the first attempt.
  //
  // This timeout normally should be greater than the cumulative timeouts in
  // StageAttemptExecutionPolicy. It should also account for some amount of time
  // for this Stage to enter the ATTEMPTING state in the first place.
  //
  // Note this timeout is enforced only when launching an attempt, i.e. if
  // a stage attempt is already running, it will always be allowed to run to its
  // completion (or an attempt timeout per its own StageAttemptExecutionPolicy).
  //
  // Note that the timeout enforcement doesn't apply to stages that are still
  // blocked on their dependencies: if a stage timeout is reached while the
  // stage is still in PLANNED state, nothing will happen to the stage state at
  // that particular moment. The stage will remain in PLANNED state until its
  // dependencies are resolved (just like happens in a normal scenario). Only
  // then will it potentially move into FINAL state due to hitting the stage
  // timeout (depending on `execute_at_least_one_attempt`).
  //
  // If unset, this timeout will not apply at all (i.e. logically this timeout
  // will be infinite).
  optional google.protobuf.Duration stage_timeout = 2;

  // If true, always launch the first attempt, totally ignoring `stage_timeout`.
  //
  // If false or unset, and the estimated stage attempt completion time exceeds
  // the stage timeout (see `stage_timeout` for details), the stage (when its
  // dependencies are unblocked) will move into FINAL state immediately without
  // running any attempts at all. StageConcludedReason will be TIMEOUT.
  optional bool execute_at_least_one_attempt = 3;

  // Template for an attempt level execution policy.
  //
  // Each attempt will be created with this policy as requested. But the
  // executor may augment the policy by merging the requested policy and what
  // is in the configs.
  optional StageAttemptExecutionPolicy attempt_execution_policy_template = 4;
}
