// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/actor.proto";
import "turboci/graph/orchestrator/v1/check_delta.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage_delta.proto";
import "turboci/graph/orchestrator/v1/value.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Edit is a record which indicates who/what/why edited a Check or
// Stage.
//
// This has a `delta` of either CheckDelta or StageDelta, depending on the
// type of the edit.
//
// Edit Deltas are designed to be quite slim. Heavy bits of the delta (like
// Option Data) will be stored separately from this Edit record and will have a
// shorter TTL.
message Edit {
  // The node which this Edit is associated with.
  optional ids.v1.Identifier for_node = 1 [
    (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
    (turboci).id.allowed = IDENTIFIER_KIND_STAGE
  ];

  // Version of the check/stage that this edit resulted in.
  //
  // When an edit applies, this `version` will match the node's version.
  optional Revision version = 2;

  // The time at which this Edit will be automatically garbage collected.
  //
  // Defaults to 180 days from the time of the Edit.
  //
  // TBD: Add RPC to extend the TTL of an Edit and its data.
  optional google.protobuf.Timestamp expire_at = 3;

  // The time at which heavyweight data associated with this Edit (e.g.
  // CheckEditOptions) will be automatically garbage collected.
  //
  // Defaults to 30 days from the time of the Edit.
  //
  // This currently has no effect for Stage edits, because Stage edits don't
  // retain any heavy data.
  //
  // TBD: Add RPC to extend the TTL of an Edit and its data.
  optional google.protobuf.Timestamp data_expire_at = 4;

  // The security realm for this Edit (duplicated from the affected Check/Stage
  // to allow easy ACL resolution).
  //
  // The premise is that if you can read a Check or Stage, you can read the
  // edits for that Check or Stage.
  optional string realm = 5 [(google.api.field_behavior) = IMMUTABLE];

  // The entity which generated this Edit.
  optional Actor created_by = 6;

  // This is the set of nodes which were included in the same WriteNodes
  // RPC as this Edit (one per `checks`, `stages`, and/or
  // `current_stage_write`). For simplicity, this will also always include
  // `for_node`.
  //
  // This may contain more nodes than were actually written in the case of
  // a partially applied write, e.g.
  //
  //   * One writer writes Check["foo", BUILD]
  //   * Another writer writes Check["foo", BUILD], Check["bar", BUILD].
  //
  // In this case, the edit on "bar" from the second write will include "foo"
  // in this set because the requested write is compatible with the state of
  // "foo".
  //
  // This can only happen with WriteNodes requests with `txn` unset (i.e.
  // 'oblivious writes').
  //
  // If you need to detect this, load e.g. `Check["foo"] / Edit[version]`. If
  // the edit does not exist, then it means foo was already written before this
  // Edit.
  repeated ids.v1.Identifier transactional_set = 7 [
    (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
    (turboci).id.allowed = IDENTIFIER_KIND_STAGE,
    // IDENTIFIER_KIND_STAGE_ATTEMPT corresponds to `current_stage_write`.
    (turboci).id.allowed = IDENTIFIER_KIND_STAGE_ATTEMPT
  ];

  // If set, then the WriteNodes which created this edit was done as an
  // 'oblivious' write - that is, `txn` was not supplied in WriteNodseRequest.
  //
  // This is intended to be a hint when debugging that a non-transactional
  // write could be an issue.
  optional bool oblivious_write = 11;

  // Human and machine-readable reasons for this Edit (provided as part of
  // WriteNodes).
  message Reason {
    // The identifier of this specific Reason.
    optional ids.v1.Identifier identifier = 4 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_EDIT_REASON,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE_EDIT_REASON
    ];

    // The security realm for this reason.
    //
    // This is set by the writer which created this Edit. In WriteNodseRequest,
    // this defaults to the writer's realm unless explicitly set, and so may
    // differ from the Edit's realm.
    //
    // The premise is that the Edit is a property of the Check/Stage but
    // details of why an Edit was made are controlled by the writer that made
    // them.
    optional string realm = 1;

    // A 'low effort' reason for this edit.
    //
    // This is 'low effort' because it's preferable for the writer to provide
    // detailed machine-readable data in the `details` field below.
    optional string message = 2;

    // Machine-readable reason(s) for this edit.
    //
    // This is repeated to allow for standardized reason message types in
    // conjunction with workflow-specific details as part of the same write
    // record.
    repeated Value details = 3;
  }
  // The writer-provided reason(s) for this Edit.
  //
  // The only reason to have multiple Reason messages is to allow for different
  // realms.
  //
  // NOTE: When viewing Edits, the reader will only see the reasons for which
  // they have read permissions (that is - two different users may see
  // different versions of this otherwise entirely-immutable Edit).
  //
  // By convention, these should be ordered from most to least specific, so if
  // a client only wants to display one Reason, it should be the first in this
  // list.
  repeated Reason reasons = 8;

  // TBD: Allow indication that this Edit is "important" to be able to garbage
  // collect it at a slower cadence?

  // The actual delta of this Edit.
  oneof delta {
    // This is a delta for a Check.
    //
    // `for_node` must be an Identifier.Check.
    CheckDelta check = 9;

    // This is a delta for a Stage.
    //
    // `for_node` must be an Identifier.Stage.
    StageDelta stage = 10;
  }
}
