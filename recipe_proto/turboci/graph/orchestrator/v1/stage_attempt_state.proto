// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// NOTE - This is StageAttemptState with prefixed enum values instead of
// Stage Attempt.State so that field_options.proto can import this without making
// a circular import with stage.proto.

// StageAttemptState describes the current state of a Stage Attempt.
//
// This state machine is much more complicated than Check or Stage state
// because:
//   * It revolves around synchronous / asynchronous state reconciliation
//     with external Executors.
//   * It subsumes a major portion of the historical WorkNode state machine in
//     a way that will allow us to be compatible with WorkNode state semantics.
//
// This state evolves like:
//
//   PENDING -> THROTTLED
//   PENDING -> RUNNING
//   PENDING -> COMPLETE
//   PENDING -> INCOMPLETE
//   PENDING -> SCHEDULED
//
//   THROTTLED -> INCOMPLETE
//   THROTTLED -> PENDING
//
//   SCHEDULED -> RUNNING
//   SCHEDULED -> COMPLETE
//   SCHEDULED -> INCOMPLETE
//
//   RUNNING -> CANCELLING
//   RUNNING -> TEARING_DOWN
//   RUNNING -> COMPLETE
//   RUNNING -> INCOMPLETE
//
//   CANCELLING -> TEARING_DOWN
//   CANCELLING -> INCOMPLETE
//
//   TEARING_DOWN -> COMPLETE
//   TEARING_DOWN -> INCOMPLETE
//
//   INCOMPLETE and COMPLETE are terminal states.
//
// The Nth Stage Attempt (i.e. any Stage Attempt after the first) may also be
// created in an AWAITING_RETRY state rather than PENDING.
//
//   AWAITING_RETRY -> PENDING
//   AWAITING_RETRY -> INCOMPLETE
//
// The Orchestrator manages Stage Attempt state evolution in conjunction with
// the Executor, and explicit state transitions made explicitly by the Stage
// Attempt itself. The only state transition which can be activated by a third
// party would be transitions to INCOMPLETE or CANCELLING done when the Stage is
// cancelled.
//
// These states have enum values in multiples of 10 in case we need to add more
// states later which fall between these initial states.
enum StageAttemptState {
  // UNKNOWN is the default, invalid, state.
  STAGE_ATTEMPT_STATE_UNKNOWN = 0;

  // This is an initial state for a Stage Attempt and indicates that the
  // Stage Attempt is available for an Executor, but either:
  //   * The Orchestrator has not yet sent this Stage Attempt to the Executor.
  //   * [WorkNode only] The Executor has advertised this Stage on pub/sub, but
  //     it has not yet been "Popped".
  //
  // This state can transition to THROTTLED, SCHEDULED, RUNNING, COMPLETE or
  // INCOMPLETE.
  STAGE_ATTEMPT_STATE_PENDING = 10;

  // This state indicates that the Stage Attempt was PENDING, but is currently
  // throttled.
  //
  // Throttling happens when the Executor explicitly marks this Stage Attempt as
  // Throttled, or if an external Update/Patch to a WorkNode increases its
  // availability_time_millis.
  //
  // This should be used by an Executor as a way to explicitly acknowledge a
  // RunStage call for a valid stage, but have the orchestrator keep this stage
  // on ice for some specified amount of time, indicated by setting the `until`
  // field when transitioning the current attempt to Throttled.
  //
  // This state can transition to PENDING or INCOMPLETE.
  STAGE_ATTEMPT_STATE_THROTTLED = 20;

  // This state indicates that the Stage Attempt was PENDING, but is now picked
  // up for execution by an Executor.
  //
  // This state can transition to RUNNING, COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_SCHEDULED = 30;

  // This state indicates that the Stage Attempt is now actually being executed
  // by an Executor.
  //
  // This state can transition to COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_RUNNING = 40;

  // This state indicates that the Stage Attempt has been cancelled, but this
  // has not yet been communicated to the running Stage Attempt.
  //
  // The Stage Attempt must be assumed to internally consider itself to be
  // RUNNING while viewing this state from the API - this means that the
  // `running` heartbeat and timeout still apply during this state.
  //
  // This state will transition to TEARING_DOWN as soon as TurboCI has
  // confirmation that the Stage Attempt knows it's been cancelled.
  //
  // This state is explicitly different than TEARING_DOWN to avoid the
  // possibility that a Stage is cancelled, but the Stage Attempt doesn't see
  // this until its next valid heartbeat - thus effectively losing up to 1.9x
  // the heartbeat interval out of its TEARING_DOWN timeout.
  STAGE_ATTEMPT_STATE_CANCELLING = 50;

  // This state indicates that the Stage Attempt is doing some work after the
  // 'RUNNING' state.
  //
  // This is meant to model things like:
  //   * doing best-effort cleanup
  //   * exporting logs or other state to other systems
  //   * things like swarming's isolated upload/cache cleanup phase
  //
  // This state will only be used if the stage attempt has execution policy with
  // a non-zero timeout for this state.
  //
  // This state can transition to COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_TEARING_DOWN = 60;

  // This is a final state which indicates that this Stage Attempt finished
  // everything the Executor intended it to do.
  //
  // NOTE: 'finished everything the Executor intended it to do' does not imply
  // workflow-level success criteria such as "all tests passed" or "the build
  // successfully compiled". This is more like "the test harness ran all of the
  // tests (regardless of their outcome)" or "the build started and all possible
  // compilation actions were done". These outcomes are highy varied and nuanced
  // (e.g. tests may be graded on flakiness, not simply pass/fail, build may
  // have failed on an optional target but successfully completed the required
  // targets). These workflow-level outcomes are reflected in the Check Results
  // which this Stage Attempt would have written during its execution.
  //
  // This state is terminal.
  STAGE_ATTEMPT_STATE_COMPLETE = 70;

  // This is a final state which indicates that this Stage Attempt was not able
  // to complete everything that the Executor intended it to do.
  //
  // The Orchestrator itself can transition the Stage Attempt to this state in
  // the event of a heartbeat timeout. This state can also be entered by
  // explicit external actions (e.g. the Executor marking the stage as
  // INCOMPLETE, or external cancellation signals).
  //
  // The Orchestrator will consult the StageExecutionPolicy, and if allowed,
  // will make a new Attempt. This can be blocked when using WriteNodes to
  // mark a Stage Attempt as INCOMPLETE by setting the `block_new_attempts`
  //
  // This state is terminal (but if a retry was requested, a new Stage Attempt
  // may be created for this Stage).
  STAGE_ATTEMPT_STATE_INCOMPLETE = 80;

  // This is an initial state and indicates that a previous Stage Attempt went
  // to INCOMPLETE and the Stage's execution policy permitted a retry.
  //
  // Transition to PENDING is automatic after the execution policy's computed
  // retry delay.
  //
  // This state can transition to PENDING or INCOMPLETE.
  STAGE_ATTEMPT_STATE_AWAITING_RETRY = 90;
}
