// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// NOTE - This is StageAttemptState with prefixed enum values instead of
// StageAttempt.State so that field_options.proto can import this without making
// a circular import with stage.proto.

// StageAttemptState describes the current state of a StageAttempt.
//
// This state machine is much more complicated than Check or Stage state
// because:
//   * It revolves around synchronous / asynchronous state reconciliation
//     with external Executors.
//   * It subsumes a major portion of the historical WorkNode state machine in
//     a way that will allow us to be compatible with WorkNode state semantics.
//
// This state evolves like:
//
//   PENDING -> THROTTLED
//   PENDING -> RUNNING
//   PENDING -> COMPLETE
//   PENDING -> INCOMPLETE
//   PENDING -> SCHEDULED
//
//   THROTTLED -> INCOMPLETE
//   THROTTLED -> PENDING
//
//   SCHEDULED -> RUNNING
//   SCHEDULED -> COMPLETE
//   SCHEDULED -> INCOMPLETE
//
//   RUNNING -> CANCELLING
//   RUNNING -> TEARING_DOWN
//   RUNNING -> COMPLETE
//   RUNNING -> INCOMPLETE
//
//   CANCELLING -> TEARING_DOWN
//   CANCELLING -> INCOMPLETE
//
//   TEARING_DOWN -> COMPLETE
//   TEARING_DOWN -> INCOMPLETE
//
//   INCOMPLETE and COMPLETE are terminal states.
//
// The Nth StageAttempt (i.e. any StageAttempt after the first) may also be
// created in an AWAITING_RETRY state rather than PENDING.
//
//   AWAITING_RETRY -> PENDING
//   AWAITING_RETRY -> INCOMPLETE
//
// The Orchestrator manages StageAttempt state evolution in conjunction with the
// Executor, and explicit state transitions made explicitly by the StageAttempt
// itself. The only state transition which can be activated by a third party
// would be transitions to INCOMPLETE or CANCELLING done when the Stage is
// cancelled.
//
// These states have enum values in multiples of 10 in case we need to add more
// states later which fall between these initial states.
enum StageAttemptState {
  // UNKNOWN is the default, invalid, state.
  STAGE_ATTEMPT_STATE_UNKNOWN = 0;

  // This is an initial state for a StageAttempt and indicates that the
  // StageAttempt is available for an Executor, but either:
  //   * The Orchestrator has not yet sent this StageAttempt to the Executor.
  //   * [WorkNode only] The Executor has advertised this Stage on pub/sub, but
  //     it has not yet been "Popped".
  //
  // This state can transition to THROTTLED, SCHEDULED, RUNNING, COMPLETE or
  // INCOMPLETE.
  STAGE_ATTEMPT_STATE_PENDING = 10;

  // This state indicates that the StageAttempt was PENDING, but is currently
  // throttled.
  //
  // Throttling happens when the Executor explicitly marks this StageAttempt as
  // Throttled, or if an external Update/Patch to a WorkNode increases its
  // availability_time_millis.
  //
  // This state can transition to PENDING or INCOMPLETE.
  //
  // TBD - Add when implemented.
  // STAGE_ATTEMPT_STATE_THROTTLED = 20;

  // This state indicates that the StageAttempt was PENDING, but is now picked
  // up for execution by an Executor.
  //
  // This state can transition to RUNNING, COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_SCHEDULED = 30;

  // This state indicates that the StageAttempt is now actually being executed
  // by an Executor.
  //
  // This state can transition to COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_RUNNING = 40;

  // This state indicates that the StageAttempt has been cancelled, but this has
  // not yet been communicated to the running STAGE_ATTEMPT.
  //
  // The StageAttempt must be assumed to internally consider itself to be
  // RUNNING while viewing this state from the API - this means that the
  // `running` heartbeat and timeout still apply during this state.
  //
  // This state will transition to TEARING_DOWN as soon as TurboCI has
  // confirmation that the StageAttempt knows it's been cancelled.
  //
  // This state is explicitly different than TEARING_DOWN to avoid the
  // possibility that a Stage is cancelled, but the Stage Attempt doesn't see
  // this until its next valid heartbeat - thus effectively losing up to 1.9x
  // the heartbeat interval out of its TEARING_DOWN timeout.
  STAGE_ATTEMPT_STATE_CANCELLING = 50;

  // This state indicates that the StageAttempt is doing some work after the
  // 'RUNNING' state.
  //
  // This is meant to model things like:
  //   * doing best-effort cleanup
  //   * exporting logs or other state to other systems
  //   * things like swarming's isolated upload/cache cleanup phase
  //
  // This state will only be used if the stage attempt has execution policy with
  // a non-zero timeout for this state.
  //
  // This state can transition to COMPLETE or INCOMPLETE.
  STAGE_ATTEMPT_STATE_TEARING_DOWN = 60;

  // This is a final state which indicates that this StageAttempt finished
  // everything the Executor intended it to do.
  //
  // NOTE: 'finished everything the Executor intended it to do' does not imply
  // workflow-level success criteria such as "all tests passed" or "the build
  // successfully compiled". This is more like "the test harness ran all of the
  // tests (regardless of their outcome)" or "the build started and all possible
  // compilation actions were done". These outcomes are highy varied and nuanced
  // (e.g. tests may be graded on flakiness, not simply pass/fail, build may
  // have failed on an optional target but successfully completed the required
  // targets). These workflow-level outcomes are reflected in the Check Results
  // which this StageAttempt would have written during its execution.
  //
  // NOTE: It is currently allowed for an Executor to request a retry of this
  // Stage, even as it marks the StageAttempt as COMPLETE. This can happen in
  // cases where the workflow-level criteria failed and the Executor wants a
  // 'quick and dirty' retry. More nuanced retries should be done at the
  // workflow level by adding additional follow-up Stages which can e.g. just
  // retry the subset of failing tests/build targets, or wait until a wider
  // analysis of other, parallel, stages have completed to make a smarter retry
  // decision.
  //
  // This state is terminal (but if a retry was requested, a new StageAttempt
  // may be created for this Stage).
  STAGE_ATTEMPT_STATE_COMPLETE = 70;

  // This is a final state which indicates that this StageAttempt was not able
  // to complete everything that the Executor intended it to do.
  //
  // The Orchestrator itself can transition the StageAttempt to this state in
  // the event of a heartbeat timeout. This state can also be entered by
  // explicit external actions (e.g. the Executor marking the stage as
  // INCOMPLETE, or external cancellation signals).
  //
  // Like COMPLETE, a retry can be requested for this state, even when the state
  // is explicitly written by the Executor. Similarly, the Executor could mark
  // the StageAttempt as INCOMPLETE without a retry for e.g. a non-retriable
  // failure (e.g. lack of resources).
  //
  // This state is terminal (but if a retry was requested, a new StageAttempt
  // may be created for this Stage).
  STAGE_ATTEMPT_STATE_INCOMPLETE = 80;

  // This is an initial state and indicates that a previous StageAttempt went to
  // a terminal state (COMPLETE or INCOMPLETE), a retry was requested, AND the
  // Stage's execution policy permitted a retry.
  //
  // Transition to PENDING is automatic after the execution policy's computed
  // retry delay.
  //
  // This state can transition to PENDING or INCOMPLETE.
  STAGE_ATTEMPT_STATE_AWAITING_RETRY = 90;
}
