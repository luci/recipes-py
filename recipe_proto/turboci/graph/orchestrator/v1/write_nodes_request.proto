// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/protobuf/timestamp.proto";
import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/check_kind.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/edge.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_execution_policy.proto";
import "turboci/graph/orchestrator/v1/value.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Request message for TurboCIOrchestrator.WriteNodes.
//
// Allows atomically writing to multiple nodes (Checks, Stages) in a single
// transaction.
message WriteNodesRequest {
  // RealmValue describes a Value which resides in a given security realm.
  //
  // This is used to write objects which appear in the graph as Datum messages.
  message RealmValue {
    // The realm to assign to this value (if the value is being created). If
    // it's unset/empty, it will inherit from the realm of the object containing
    // it (so, for Check options or result data, this would be the Check's
    // realm).
    //
    // If provided, must be the absolute form "<project>:<name>".
    //
    // If the value is being overwritten and `realm` is provided, it must match
    // the already-written value's realm.
    optional string realm = 1 [(turboci).creation_only = true];

    // The value to set.
    optional Value value = 2;
  }

  // An in-line representation of Dependencies.Group.
  //
  // The Orchestrator will deduplicate edges into Dependencies.edges in the
  // Check or Stage.
  //
  // Otherwise this has the same meaning as Dependencies.Group.
  message DependencyGroup {
    // Singular edges in this group.
    repeated Edge edges = 1;

    // Sub-groups in this group.
    //
    // May not contain empty groups.
    repeated DependencyGroup groups = 2;

    // Number of edges and/or groups which need to be satisfied for this
    // DependencyGroup to be satisfied.
    //
    // See `Dependencies.Group.threshold`.
    optional int32 threshold = 3;
  }

  // A single Stage.Attempt.Progress write message.
  message StageAttemptProgress {
    // Low-effort/human-readable progress information.
    //
    // Better than nothing, but not good for machines to parse.
    optional string message = 1;

    // Machine-readable details for this progress item.
    repeated Value details = 2;

    // An optional field for preventing duplicate progress messages.
    //
    // If you don't care about duplicate progress messages on retried RPCs, you
    // can ignore this field.
    //
    // Otherwise, if set, this field must be unique per progress message, per
    // Stage Attempt.
    //
    // Writing multiple progress messages with the same idempotency_key, but
    // different `message` or `details` fields is an error.
    //
    // It is recommended to set this field like "<thread_id>/<unique>" where
    // <thread_id> identifies a single actor within the Executor, in the
    // context of the current stage attempt token, and <unique> is some unique
    // value for that actor, for the Stage Attempt.
    //
    // Examples:
    //   * server/<purpose> - messages emitted by the server on behalf of a
    //     working bot with some specific purpose (e.g. "server/final").
    //   * bot/<sequence> etc. - messages emitted by the bot from a single
    //     process on a machine somewhere. The process keeps <sequence> as a
    //     simple counter in-memory.
    //   * <uuid> - 36 bytes of stringy goodness. Hopefully your progress
    //     messages are much longer than this :)
    //
    // This solves the problem where:
    //   * you do a write with a progress message (e.g. "hello"), but fail to
    //     get the OK response (network, cosmic rays, etc.).
    //   * you then retry the RPC.
    //
    // If the WriteNodesRequest has a TransactionDetails, the retry will fail,
    // and after getting the current Stage Attempt state, you would need to
    // scan through the existing Progress messages to see if the message
    // "hello" is present (assuming that "hello" is actually a unique progress
    // message in the first place).
    //
    // If the WriteNodesRequest does NOT have a TransactionDetails, the new
    // message will just be appended silently, and you will end up with two
    // "hello" messages.
    //
    // Setting the idempotency_key to a per-Attempt-unique value will prevent
    // this; this Progress message will be recorded at most once on the
    // Attempt, and on the retry, the orchestrator will know that this message
    // was already recorded and will be able to return OK without duplicating
    // it.
    optional string idempotency_key = 3;
  }

  // The token which constrains this write to a specific Workplan (and possibly
  // to a Stage Attempt in that Workplan).
  //
  // A suitable token is provided to the Executor of a Stage or to the creator
  // of an empty Workplan.
  //
  // This is in addition to regular RPC authorization.
  //
  // If missing, this RPC will check that the caller additionally has the
  // 'turboci.workplans.writeExternal' permission on Workplan(s) in the
  // CheckWrites/StageWrites.
  optional string token = 1;

  // Reason is the write-request analogue of Edit.Reason.
  //
  // NOTE: If this WriteNodes is a no-op because it's a retry of a previous
  // successful WriteNodes, these Reasons will not be recorded in the graph
  // because there will not be any applied writes. This means that if you
  // vary the Reasons from retry to retry, it's possible to see a successful
  // WriteNodes where the provided reasons are not retained.
  message Reason {
    // The security realm for this reason.
    //
    // If provided, must be the absolute form "<project>:<name>".
    //
    // If absent the written Stage will copy its realm from the implied realm
    // of the `token`. For Stage Attempt tokens, this will be the Stage's
    // realm, and for Creator tokens, this will be the WorkPlan's realm.
    optional string realm = 1 [(turboci).realm_inherits_writer = true];

    // A 'low effort' reason for this edit.
    //
    // This is 'low effort' because it's preferable for the writer to provide
    // detailed machine-readable data in the `details` field below.
    optional string message = 2;

    // Machine-readable reason(s) for this edit.
    //
    // This is repeated to allow for standardized reason message types in
    // conjunction with workflow-specific details as part of the same write
    // record.
    repeated Value details = 3;
  }
  // The reason for this write operation, as supplied by the entity performing
  // the write.
  //
  // This should be used to detail any information about WHY this write is
  // happening, or details about what changes are being made.
  //
  // This will be reflected in the CheckEdit or StageEdit logs for all
  // Checks and/or Stages affected by this write.
  //
  // This is repeated to allow reasons in multiple security domains; By
  // convention, these should be ordered from most to least specific, so if
  // a client only wants to display one Reason, it should be the first in this
  // list which they have access to.
  repeated Reason reasons = 2;

  // TransactionDetails encapsulates the information necessary to make this
  // write safe by describing the snapshot of the graph which the writer
  // observed. TurboCI Orchestrator will transactionally ensure that these
  // nodes haven't changed since the writer observed them.
  //
  // TurboCI Orchestrator will implicitly include all nodes which are being
  // written to - this message can provide additional nodes to that set.
  //
  // It is valid to include nodes which were absent from the snapshot, if the
  // writer wants to make its write conditional on their absence.
  //
  // Transaction Procedure:
  //   retry {
  //     nodes, snapshot_version = QueryNodes(...)
  //     # computations
  //
  //     more_nodes, _ = QueryNodes(..., ensure_version=snapshot_version)
  //     # This will cause QueryNodes to fail if any returned nodes have
  //     # a version greater than `snapshot_version`. This will allow the
  //     # transaction loop to retry immediately, rather than waiting for the
  //     # WriteNodes call.
  //
  //     # computations
  //
  //     if WriteNodes(..., txn={nodes+more_nodes, snapshot_version}) {
  //       # Success!
  //
  //       # If you need to make another transaction, you CAN use the
  //       # written_version in the response as an input snapshot_version to
  //       # the subsequent transaction. However, it's important that if this
  //       # second transaction gets a conflict, it restart with
  //       # snapshot_version unset.
  //       break
  //     } else {
  //       # failure - retry from the top
  //     }
  //   }
  message TransactionDetails {
    // A list of all nodes observed which lead to this write.
    //
    // This SHOULD include all nodes which your computation used as inputs
    // for making a decision. If you locally filtered the GraphView before the
    // computation, it is OK to omit nodes which were filtered out, because you
    // would do the same write regardless of those filtered nodes' content.
    //
    // This MAY include nodes which were absent from the GraphView - this means
    // that the write is conditional on their absence (e.g. "I queried for X and
    // didn't find it, so I'm doing a write based on that information. If X DOES
    // exist at the time of the write, I want to abort and try again.").
    //
    // NOTE: If you are writing what you THINK are all new nodes, but haven't
    // done a query to verify this, just providing `txn` with `nodes_observed`
    // and `snapshot_version` left unset is sufficient to guard against the
    // nodes already being written. However, if you get
    // a TransactionConflictFailure because the nodes already exist, when you
    // recover make sure to do the query before you try the write again! You
    // may be conflicting with a previous incarnation of your own process!
    repeated ids.v1.Identifier nodes_observed = 1 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_OPTION,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_RESULT_DATUM,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE
    ];

    // The 'version' of the GraphView returned from QueryNodes.
    //
    // If multiple queries were made in this transaction, this revision MUST be
    // the first revision observed. Providing version.require to QueryNodes
    // will help enforce this.
    //
    // If `snapshot_version` is unset, it is treated as a 0 value (which means
    // that all `nodes_observed` plus all nodes being written in this request
    // must not already exist).
    optional Revision snapshot_version = 2;
  }
  // Set if the caller wants to make this write transactional with a subset of
  // the graph at a particular snapshot.
  //
  // If this is unset, then this is an 'oblivious write' and any valid writes
  // will apply/overwrite the current database state, assuming they are
  // semantically valid (i.e. it will still not be possible to change a Check's
  // realm, or roll a Check's state backwards, etc.).
  //
  // There are common cases where this will be left unset, for example when a
  // Stage Attempt updates its own progress based on its own internal state, or
  // when a Stage Attempt records results for a Check off of some internal
  // computation. It's allowed for a Stage Attempt to tie this progress update
  // to the state of the graph, but it's not expected or required.
  optional TransactionDetails txn = 3;

  // A description of modifications to make to a single Check.
  message CheckWrite {
    // The check to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `token`, if it's provided.
    //
    // Otherwise, the Check must belong to the token's WorkPlan, or the caller
    // must have the additional "turboci.workplans.writeExternal" permission in
    // the check's realm (or in the realm of the option/result data).
    optional ids.v1.Check identifier = 1;

    // Realm to assign to this check.
    //
    // If provided, must be the absolute form "<project>:<name>".
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing realm.
    //
    // If absent and this CheckWrite creates the Check, the written Check will
    // copy its realm from the implied realm of the `token`. For Stage Attempt
    // tokens, this will be the Stage's realm, and for Creator tokens, this
    // will be the WorkPlan's realm.
    //
    // If `token` is unset and this field is absent, the write will be rejected.
    optional string realm = 2 [
      (turboci).creation_only = true,
      (turboci).realm_inherits_writer = true
    ];

    // Kind to assign to this check.
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing Check kind.
    optional CheckKind kind = 3 [(turboci).creation_only = true];

    // The list of Options to write/overwrite.
    //
    // Must be unique on `RealmValue.value.type_url`.
    repeated RealmValue options = 4 [(turboci).check.editable = CHECK_STATE_PLANNING];

    // Dependency predicate for this Check.
    //
    // If set, used to populate the dependencies.edges and
    // dependencies.predicate fields in the target Check.
    //
    // To clear dependencies, set this to an empty DependencyGroup.
    optional DependencyGroup dependencies = 5 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).check.editable = CHECK_STATE_PLANNING
    ];

    // Write data to a Result for this Check.
    //
    // The Result to write in is keyed on:
    //   * The Stage Attempt (if `token` is provided)
    //   * The caller's identity (if `token` is absent)
    //
    // If the given keyed Result does not exist, it will be automatically
    // created. Multiple calls to WriteNodes from this same Stage Attempt or
    // service account will update the same Result, and the Result will be
    // automatically finalized when this Stage Attempt ends (if a WriteNodes
    // with `finalize_results` is not called before then).
    //
    // The data here will overwrite existing data of the same type in the
    // selected Result for this Stage Attempt.
    repeated RealmValue results = 6 [(turboci).check.editable = CHECK_STATE_WAITING];

    // If set, finalize the Check.Result.
    //
    // No more data may be written to the Result from the caller after this is
    // set.
    optional bool finalize_results = 7 [(turboci).check.editable = CHECK_STATE_WAITING];

    // The new state of this Check.
    //
    // If set, must be equal to, or greater than, the current state of the
    // Check.
    optional CheckState state = 8;
  }
  // Write to zero or more Checks.
  repeated CheckWrite checks = 4;

  // A description of modifications to make to a single Stage.
  //
  // Note that the `state` of a Stage is managed entirely by the Orchestrator
  // itself. If you are a Stage implementation and need to manage the state of
  // your own Stage Attempt, see CurrentStageWrite.
  message StageWrite {
    // The stage to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `token`, if it's provided.
    //
    // Otherwise, the Stage must belong to the token's WorkPlan, or the caller
    // must have the additional "turboci.workplans.writeExternal" permission in
    // the stage's realm.
    //
    // The `is_worknode` field should also be omitted - it will be filled in by
    // the server according to the type of `args`.
    optional ids.v1.Stage identifier = 1;

    // The arguments of the Stage.
    //
    // A Stage MUST have `args` - if this write would create the Stage and
    // `args` is omitted, the write will be rejected.
    //
    // TBD: Document executor registration/selection process.
    //
    // TBD: What to do on double-creation? Do we compare args (protobuf
    // serialization is not canonical/deterministic, but in practice if the
    // same process creates the same stage twice, it will likely have the same
    // args).
    //
    // We could just accept 'same type' == OK and ignore the value, but this
    // feels a bit wishy-washy.
    optional Value args = 2 [(turboci).creation_only = true];

    // Realm to assign to this Stage.
    //
    // If provided, must be the absolute form "<project>:<name>".
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing realm.
    //
    // If absent the written Stage will copy its realm from the implied realm of
    // the `token`. For Stage Attempt tokens, this will be the Stage's realm,
    // and for Creator tokens, this will be the WorkPlan's realm.
    //
    // If `token` is unset and this field is absent, the write will be rejected.
    optional string realm = 3 [
      (turboci).creation_only = true,
      (turboci).realm_inherits_writer = true
    ];

    // Dependency predicate for this Stage.
    //
    // If set, used to populate the dependencies.edges and
    // dependencies.predicate fields in the target Check.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing dependencies identically.
    //
    // NOTE: Currently Stages in this group must only point to Stages created by
    // the Stage performing this write. In theory, this should help prevent
    // excessive coupling between different, unrelated, stage implementations.
    //
    // If arbitrary stage dependencies are allowed, it could cause errors when
    // an upstream stage changes it's implementation and no longer produces the
    // stages the downstream one expects. Instead, the upstream stage should
    // create a Check which can remain stable across the implementation
    // versions, and the downstream stages should depend on that.
    //
    // However, if the current writer is the one creating the stages, then there
    // is no implementation risk.
    optional DependencyGroup dependencies = 4 [
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).creation_only = true
    ];

    // The requested execution policy of the Stage.
    //
    // If the Stage already exists, this will only result in an error if this
    // requested policy doesn't match doesn't match the existing requested
    // policy.
    //
    // If this write creates the stage and the requested_stage_execution_policy
    // is omitted, the stage will get the default StageExecutionPolicy from the
    // Executor.
    optional StageExecutionPolicy requested_stage_execution_policy = 5 [(turboci).creation_only = true];

    // The Check assignments of the Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing assignments.
    repeated Stage.Assignment assignments = 6 [(turboci).creation_only = true];

    // If true, ensures that this Stage is marked for cancellation.
    //
    // If the Stage is in the ATTEMPTING state, and the current Attempt is
    // RUNNING, the Attempt will transition to CANCELLING - Otherwise the
    // current Attempt will be marked INCOMPLETE.
    //
    // If the Stage is already marked for cancellation, setting this is a no-op.
    //
    // A value of `false` is the same as `unset` (no-op).
    //
    // Use the top-level `reason` field to provide the cancellation reason.
    optional bool cancelled = 7;
  }
  // Write to zero or more Stages.
  repeated StageWrite stages = 5;

  // Internal writes for the Stage Attempt indicated by the token.
  //
  // These aspects come from either the Executor which owns this Stage Attempt,
  // or the running Stage Attempt process.
  message CurrentAttemptWrite {
    // Sets details in the Stage Attempt.details field.
    //
    // Overwrites any existing detail of the same type.
    repeated Value details = 1;

    // Progress messages to add to the current Stage Attempt.
    //
    // See StageAttemptProgress.idempotency_key to prevent duplicate appends on
    // network flake.
    repeated StageAttemptProgress progress = 2;

    // Indicate how the Orchestrator should transition to a given state.
    message StateTransition {
      // Throttled indicates that the Executor can run this Attempt, just not
      // right now.
      message Throttled {
        // Specifies that the Stage Attempt should not be made PENDING again
        // (and thus sent to the Executor via RunStage) until this time.
        //
        // Specifying a time in the past will cause the write to be a no-op
        // (which will leave the Attempt in the PENDING state).
        //
        // Required.
        optional google.protobuf.Timestamp until = 1;
      }

      // Scheduled indicates that the Executor has accepted the Attempt, and
      // will run it at a later time.
      message Scheduled {
        // The execution policy for this Stage Attempt.
        //
        // Optional.
        optional StageAttemptExecutionPolicy attempt_execution_policy = 1;
      }

      // Running indicates that the Executor is actively running this Attempt.
      message Running {
        // The execution policy for this Stage Attempt.
        //
        // This should only be used if it wasn't already set in SCHEDULED.
        // If it's set for both SCHEDULED and RUNNING, it must be the same
        // value.
        //
        // Optional.
        optional StageAttemptExecutionPolicy attempt_execution_policy = 1;

        // Sets the Stage.Attempt.process_uid field.
        //
        // If the field is already populated in the Stage Attempt, this value
        // must match - otherwise the write is rejected with an error detail
        // of StageAttemptClaimedFailure.
        //
        // Refer to Stage.Attempt.process_uid.
        //
        // Required.
        optional string process_uid = 2;
      }

      // TearingDown indicates that the Executor has either finished RUNNING
      // the Attempt, or the Stage was cancelled and the Executor is doing
      // its final cleanup for a previously-RUNNING Attempt.
      message TearingDown {
        // Nothing here for now.
      }

      // Complete indicates that the Executor has finished all work on this
      // Attempt, and the Stage can now move into its next state.
      //
      // NOTE: See STAGE_ATTEMPT_COMPLETE. Completing a Stage does not imply
      // workflow-level success like "the code compiled successfully" or "the
      // tests all passed". It simply means that e.g. the requested build ran
      // to completion, or the test harness executed all the tests.
      // Workflow-level records like compilation success/failure or test
      // execution success/failure should be recorded in the Checks for those
      // things as specific Result data.
      message Complete {
        // Nothing here for now.
      }

      // Incomplete indicates an Executor-level failure which prevented the
      // stage from running to completion.
      //
      // By convention, the reason for this should be reflected in the final
      // Progress message (which, unlike the write reasons, will not be
      // garbage collected after some amount of time).
      //
      // NOTE: See STAGE_ATTEMPT_INCOMPLETE. Similar to COMPLETE, INCOMPLETE
      // is used to indicate failure of the stage to complete it's desired
      // task (e.g. compiler segfaulted, test harness lost contact with a DUT
      // during test execution (and such a failure may not be due to the test
      // itself), etc.)
      message Incomplete {
        // Controls if this Stage should make another Attempt.
        //
        // If true, then no new Attempt is made, even if policy would permit one.
        //
        // Optional.
        optional bool block_new_attempts = 1;
      }

      // Required - the state that this StateTransition wants to move
      // to.
      oneof desired_state {
        // Move to the THROTTLED state.
        //
        // Current state must be PENDING.
        Throttled throttled = 1;

        // Move to the SCHEDULED state.
        //
        // Current state must be PENDING.
        Scheduled scheduled = 2;

        // Move to the RUNNING state.
        //
        // Current state must be PENDING or SCHEDULED.
        Running running = 3;

        // Move to the TEARING_DOWN state.
        //
        // Current state must be RUNNING or CANCELLING.
        TearingDown tearing_down = 4;

        // Move to the COMPLETE state.
        //
        // Current state must be PENDING, SCHEDULED, RUNNING or TEARING_DOWN.
        Complete complete = 5;

        // Move to the INCOMPLETE state.
        //
        // Current state must be PENDING, SCHEDULED, RUNNING or TEARING_DOWN.
        Incomplete incomplete = 6;
      }
    }
    // A state transition to make in this write.
    optional StateTransition state_transition = 3;
  }
  // State for the current Stage Attempt as indicated by `token`.
  //
  // It is invalid to set this without also setting `token`.
  //
  // A WriteNodes call with `current_attempt` set (even when it is empty) acts
  // as a heartbeat for the current Stage Attempt indicated by the token. If
  // you need to implement the 'simplest heartbeat', you can make a WriteNodes
  // call with just the token and an empty `current_attempt {}`.
  //
  // WriteNodes calls that don't have `current_attempt` set do not affect the
  // heartbeat timer. This makes such calls less likely to hit transaction
  // collisions (since they don't try to concurrently modify the heartbeat
  // timer). This may be useful if you want to make concurrent WriteNodes calls
  // from the same Stage Attempt, or even closely-sequential WriteNodes calls
  // (to non-overlapping portions of the graph) from the same Stage Attempt.
  //
  // All else being equal, it's better to do fewer, larger, WriteNodes calls
  // than many small WriteNodes calls.
  optional CurrentAttemptWrite current_attempt = 6;

  // Internal writes for the Stage indicated by the token.
  message CurrentStageWrite {
    // Continuation Group predicate for this Stage.
    //
    // If set, used to populate the continuation_group.edges and
    // continuation_group.predicate fields in this Stage.
    //
    // Edges here must only point to Stages which were created_by this Stage.
    //
    // If continuation_group is already set, this will overwrite the existing
    // continuation_group.
    optional DependencyGroup continuation_group = 1 [(turboci).id.allowed = IDENTIFIER_KIND_STAGE];
  }
  // State for the current Stage as indicated by `token`.
  //
  // It is invalid to set this without also setting `token`.
  //
  // This does not impact the heartbeat timer for the current attempt.
  optional CurrentStageWrite current_stage = 7;
}
