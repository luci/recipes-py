// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/protobuf/any.proto";
import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/check_kind.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/edge.proto";
import "turboci/graph/orchestrator/v1/edge_group.proto";
import "turboci/graph/orchestrator/v1/edit.proto";
import "turboci/graph/orchestrator/v1/execution_policy.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_state.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Request message for TurboCIOrchestrator.WriteNodes.
//
// Allows atomically writing to multiple nodes (Checks, Stages) in a single
// transaction.
message WriteNodesRequest {
  // RealmValue describes a standard Any which resides in a given security
  // realm.
  message RealmValue {
    // The realm to assign to this value (if the value is being created).
    // If it's unset/empty, it will inherit from the realm of the Stage
    // indicated by stage_attempt_token. If it's unset/empty and there is no
    // stage_attempt_token, the update will be rejected.
    //
    // If the value is being overwritten and `realm` is provided, it must match
    // the already-written value's realm.
    optional string realm = 1 [(turboci).creation_only = true];

    // The value to set.
    optional google.protobuf.Any value = 2;
  }

  // The token of the Stage Attempt which is performing this write.
  //
  // This is in addition to regular RPC authorization.
  //
  // If missing, this RPC will check that the caller additionally has the
  // 'turboci.workplans.writeExternal' permission on Workplan(s) in the
  // CheckWrites/StageWrites.
  optional string stage_attempt_token = 1;

  // The reason for this write operation, as supplied by the entity performing
  // the write.
  //
  // This should be used to detail any information about WHY this write is
  // happening, or details about what changes are being made.
  //
  // This will be reflected in the CheckEdit or StageEdit logs for all
  // Checks and/or Stages affected by this write.
  //
  // This is repeated to allow reasons in multiple security domains; By
  // convention, these should be ordered from most to least specific, so if
  // a client only wants to display one Reason, it should be the first in this
  // list which they have access to.
  repeated Edit.Reason reasons = 2;

  // TransactionDetails encapsulates the information necessary to make this
  // write safe by describing the snapshot of the graph which the writer
  // observed. TurboCI Orchestrator will transactionally ensure that these nodes
  // haven't changed since the writer observed them.
  //
  // TurboCI Orchestrator will implicitly include all nodes which are being
  // written to - this message can provide additional nodes to that set.
  //
  // It is valid to include nodes which were absent from the snapshot, if the
  // writer wants to make its write conditional on their absence.
  //
  // Transaction Procedure:
  //   retry {
  //     nodes, snapshot_version = QueryNodes(...)
  //     # computations
  //
  //     more_nodes, _ = QueryNodes(..., ensure_version=snapshot_version)
  //     # This will cause QueryNodes to fail if any returned nodes have
  //     # a version greater than `snapshot_version`. This will allow the
  //     # transaction loop to retry.
  //
  //     # computations
  //
  //     if WriteNodes(..., txn={nodes+more_nodes, snapshot_version}) {
  //       # Success!
  //
  //       # It would be technically possible to use the written_version field from the
  //       # response to do another WriteNodes call, assuming you supply a subset of
  //       # the `nodes_observed` to the new write. However, if this second write fails,
  //       # you must restart the second write process from after the first Write.
  //       #
  //       # It is simplest to just start a second transaction loop, including potentially
  //       # re-reading the nodes_observed.
  //       break
  //     } else {
  //       # failure - retry from the top
  //     }
  //   }
  message TransactionDetails {
    // A list of all nodes observed which lead to this write.
    //
    // This SHOULD include all nodes which your computation used as inputs
    // for making a decision. If you locally filtered the GraphView before the
    // computation, it is OK to omit nodes which were filtered out, because you
    // would do the same write regardless of those filtered nodes' content.
    //
    // This MAY include nodes which were absent from the GraphView - this means
    // that the write is conditional on their absence (e.g. "I queried for X and
    // didn't find it, so I'm doing a write based on that information. If X DOES
    // exist at the time of the write, I want to abort and try again.").
    //
    // NOTE: If you are writing what you THINK is a new node, the safe thing to
    // do is to query for that node before doing the write (to confirm it
    // doesn't exist) and then also include that node ID in this list (to
    // confirm it didn't start existing before your write).
    repeated ids.v1.Identifier nodes_observed = 1 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_OPTION,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_RESULT_DATUM,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE
    ];

    // The 'version' of the GraphView returned from QueryNodes.
    //
    // If multiple queries were made in this transaction, this revision MUST be
    // the first revision observed. Providing version.require to QueryNodes will
    // help enforce this.
    optional Revision snapshot_version = 2;
  }
  // Set if the caller wants to make this write transactional with a subset of
  // the graph at a particular snapshot.
  //
  // If this is unset, then this is an 'oblivious write' and any valid writes
  // will apply/overwrite the current database state, assuming they are
  // semantically valid (i.e. it will still not be possible to change a Check's
  // realm, or roll a Check's state backwards, etc.).
  //
  // There are common cases where this will be left unset, for example when a
  // Stage Attempt updates its own progress based on its own internal state, or
  // when a Stage Attempt records results for a Check off of some internal
  // computation. It's allowed for a Stage Attempt to tie this progress update
  // to the state of the graph, but it's not expected or required.
  optional TransactionDetails txn = 3;

  // A description of modifications to make to a single Check.
  message CheckWrite {
    // The check to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `stage_attempt_token`, if it's provided.
    //
    // Otherwise, the Check must belong to the stage_attempt_token's WorkPlan,
    // or the caller must have the additional "turboci.workplans.writeExternal"
    // permission in the check's realm (or in the realm of the option/result
    // data).
    optional ids.v1.Check check = 1;

    // Realm to assign to this check.
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing realm.
    //
    // If absent and this CheckWrite creates the Check, the written Check will
    // copy its realm from the Stage doing the write (assuming
    // `stage_attempt_token` is set). If `stage_attempt_token` is unset and this
    // field is absent, the write will be rejected.
    optional string realm = 2 [(turboci).creation_only = true];

    // Kind to assign to this check.
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing Check kind.
    optional CheckKind kind = 3 [(turboci).creation_only = true];

    // The list of Options to write/overwrite.
    //
    // Must be unique on `RealmValue.value.type_url`.
    repeated RealmValue options = 4 [(turboci).check.editable = CHECK_STATE_PLANNING];

    // Dependencies for this Check.
    //
    // If set, fully overwrites the dependencies field in the target Check.
    //
    // Empty groups will be pruned from this. You can remove all dependencies by
    // providing a single, empty, EdgeGroup.
    //
    // If this Write transitions the Check to PLANNED and also provides
    // dependencies, these must match identically to the already-written
    // dependencies.
    repeated EdgeGroup dependencies = 5 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).check.editable = CHECK_STATE_PLANNING
    ];

    // Write data to a Result for this Check.
    //
    // The Result to write in is keyed on:
    //   * The Stage Attempt (if stage_attempt_token is provided)
    //   * The caller's identity (if stage_attempt_token is absent)
    //
    // If the given keyed Result does not exist, it will be automatically
    // created. Multiple calls to WriteNodes from this same StageAttempt or
    // service account will update the same Result, and the Result will be
    // automatically finalized when this StageAttempt ends (if a WriteNodes with
    // `finalize_results` is not called before then).
    //
    // The data here will overwrite existing data of the same type in the
    // selected Result for this StageAttempt.
    repeated RealmValue results = 6 [(turboci).check.editable = CHECK_STATE_WAITING];

    // If set, finalize the Check.Result.
    //
    // No more data may be written to the Result from the caller after this is
    // set.
    optional bool finalize_results = 7 [(turboci).check.editable = CHECK_STATE_WAITING];

    // The new state of this Check.
    //
    // If set, must be equal to, or greater than, the current state of the
    // Check.
    optional CheckState state = 8;
  }
  // Write to zero or more Checks.
  repeated CheckWrite checks = 4;

  // A description of modifications to make to a single Stage.
  //
  // Note that the `state` of a Stage is managed entirely by the Orchestrator
  // itself. If you are a Stage implementation and need to manage the state of
  // your own StageAttempt, see CurrentStageWrite.
  message StageWrite {
    // The stage to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `stage_attempt_token`, if it's provided.
    //
    // Otherwise, the Stage must belong to the stage_attempt_token's WorkPlan,
    // or the caller must have the additional "turboci.workplans.writeExternal"
    // permission in the stage's realm.
    optional ids.v1.Stage stage = 1;

    // The arguments of the Stage.
    //
    // A Stage MUST have `args` - if this write would create the Stage and
    // `args` is omitted, the write will be rejected.
    //
    // TBD: Document executor registration/selection process.
    //
    // TBD: What to do on double-creation? Do we compare args (protobuf
    // serialization is not canonical/deterministic, but in practice if the
    // same process creates the same stage twice, it will likely have the same
    // args).
    //
    // We could just accept 'same type' == OK and ignore the value, but this
    // feels a bit wishy-washy.
    optional google.protobuf.Any args = 2 [(turboci).creation_only = true];

    // Realm to assign to this Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing realm.
    //
    // If absent, the written Stage will copy its realm from the Stage doing
    // the write (assuming `stage_attempt_token` is set). If
    // `stage_attempt_token` is unset and this field is absent, the write will
    // be rejected.
    optional string realm = 3 [(turboci).creation_only = true];

    // Dependencies for this Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing dependencies identically.
    repeated EdgeGroup dependencies = 4 [
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).creation_only = true
    ];

    // The requested retry policy of the Stage.
    //
    // If the Stage already exists, this will only result in an error if this
    // requested policy doesn't match doesn't match the existing requested policy.
    //
    // If this write creates the stage and the requested_execution_policy is
    // omitted, the stage will get the default ExecutionPolicy from the
    // Executor.
    optional ExecutionPolicy requested_execution_policy = 5 [(turboci).creation_only = true];

    // The Check assignments of the Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing assignments.
    repeated Stage.Assignment assignments = 6 [(turboci).creation_only = true];

    // If true, ensures that this Stage is marked for cancellation.
    //
    // If the Stage is in the ATTEMPTING state, and the current Attempt is
    // RUNNING, the Attempt will transition to CANCELLING - Otherwise the
    // current Attempt will be marked INCOMPLETE.
    //
    // If the Stage is already marked for cancellation, setting this is a no-op.
    //
    // A value of `false` is the same as `unset` (no-op).
    //
    // Use the top-level `reason` field to provide the cancellation reason.
    optional bool cancelled = 7;

    // TBD: Other Adjustments ?
    // TBD: Dynamic Execution Policy
  }
  // Write to zero or more Stages.
  repeated StageWrite stages = 5;

  // Internal writes for the Stage indicated by the token.
  //
  // These aspects come from either the Executor which owns this Stage Attempt,
  // or the running Stage Attempt process.
  message CurrentStageWrite {
    // Report the attempt's current state. This can only make the following
    // transitions (since all other transitions are handled by the Orchestrator
    // itself):
    //
    //   * SCHEDULED -> RUNNING
    //   * SCHEDULED -> COMPLETE
    //   * SCHEDULED -> INCOMPLETE
    //   * RUNNING -> TEARING_DOWN
    //   * RUNNING -> COMPLETE
    //   * RUNNING -> INCOMPLETE
    optional StageAttemptState state = 1;

    // Ensure all provided edges are included in `Stage.continuation_group`.
    //
    // Edges are deduplicated with `Stage.continuation_group` if they have the
    // same `target`.
    //
    // TBD: When edges have conditions, will want to coalesce the conditions
    // with `and` instead? Or just reject multiple conditional Edges with the
    // same target? Or replace the condition in the existing Edge?
    repeated Edge ensure_in_continuation_group = 3;

    // TBD: WorkerID/nonce/dedup key to ensure `SCHEDULED -> RUNNING` only
    // happens for one logical process/thread.

    // TBD: Other StageAttempt trivia (links to underlying system, Any(s) for
    // structured data about the StageAttempt, build id/task id).
    //
    // Can we make this immutable once written?

    // TBD: Attempt Progress
  }
  // State for the current Stage as indicated by `stage_attempt_token`.
  //
  // It is invalid to set this without also setting `stage_attempt_token`.
  //
  // All WriteNodes calls with a token act as a heartbeat for the current Stage
  // Attempt indicated by the token. If you need to implement the 'simplest
  // heartbeat', you can make a WriteNodes call with the token set and nothing
  // else.
  //
  // TBD: Document the SCHEDULED -> RUNNING state transition requirements (i.e.
  // setting a unique worker_id and handling multiple logicall processes all
  // trying to transition to RUNNING at the same time).
  optional CurrentStageWrite current_stage = 6;
}
