// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/ids/v1/identifier.proto";
import "turboci/graph/orchestrator/v1/check_kind.proto";
import "turboci/graph/orchestrator/v1/check_state.proto";
import "turboci/graph/orchestrator/v1/edge.proto";
import "turboci/graph/orchestrator/v1/field_options.proto";
import "turboci/graph/orchestrator/v1/revision.proto";
import "turboci/graph/orchestrator/v1/stage.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_execution_policy.proto";
import "turboci/graph/orchestrator/v1/stage_attempt_state.proto";
import "turboci/graph/orchestrator/v1/stage_execution_policy.proto";
import "turboci/graph/orchestrator/v1/value.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// Request message for TurboCIOrchestrator.WriteNodes.
//
// Allows atomically writing to multiple nodes (Checks, Stages) in a single
// transaction.
message WriteNodesRequest {
  // RealmValue describes a Value which resides in a given security realm.
  //
  // This is used to write objects which appear in the graph as Datum messages.
  message RealmValue {
    // The realm to assign to this value (if the value is being created).
    // If it's unset/empty, it will inherit from the realm of the Stage
    // indicated by stage_attempt_token. If it's unset/empty and there is no
    // stage_attempt_token, the update will be rejected.
    //
    // If the value is being overwritten and `realm` is provided, it must match
    // the already-written value's realm.
    optional string realm = 1 [(turboci).creation_only = true];

    // The value to set.
    optional Value value = 2;
  }

  // An in-line representation of Dependencies.Group.
  //
  // The Orchestrator will deduplicate edges into Dependencies.edges in the
  // Check or Stage.
  //
  // Otherwise this has the same meaning as Dependencies.Group.
  message DependencyGroup {
    // Singular edges in this group.
    repeated Edge edges = 1;

    // Sub-groups in this group.
    //
    // May not contain empty groups.
    repeated DependencyGroup groups = 2;

    // Number of edges and/or groups which need to be satisfied for this
    // DependencyGroup to be satisfied.
    //
    // See `Dependencies.Group.threshold`.
    optional int32 threshold = 3;
  }

  // A single Stage.Attempt.Progress write message.
  message StageAttemptProgress {
    // Low-effort/human-readable progress information.
    //
    // Better than nothing, but not good for machines to parse.
    optional string msg = 1;

    // Machine-readable details for this progress item.
    repeated Value details = 2;
  }

  // The token of the Stage Attempt which is performing this write.
  //
  // This is in addition to regular RPC authorization.
  //
  // If missing, this RPC will check that the caller additionally has the
  // 'turboci.workplans.writeExternal' permission on Workplan(s) in the
  // CheckWrites/StageWrites.
  optional string stage_attempt_token = 1;

  // Reason is the write-request analogue of Edit.Reason.
  message Reason {
    // The security realm for this reason.
    //
    // If omitted, this will be the same as the parent node's realm.
    optional string realm = 1;

    // A 'low effort' reason for this edit.
    //
    // This is 'low effort' because it's preferable for the writer to provide
    // detailed machine-readable data in the `details` field below.
    optional string reason = 2;

    // Machine-readable reason(s) for this edit.
    //
    // This is repeated to allow for standardized reason message types in
    // conjunction with workflow-specific details as part of the same write
    // record.
    repeated Value details = 3;
  }
  // The reason for this write operation, as supplied by the entity performing
  // the write.
  //
  // This should be used to detail any information about WHY this write is
  // happening, or details about what changes are being made.
  //
  // This will be reflected in the CheckEdit or StageEdit logs for all
  // Checks and/or Stages affected by this write.
  //
  // This is repeated to allow reasons in multiple security domains; By
  // convention, these should be ordered from most to least specific, so if
  // a client only wants to display one Reason, it should be the first in this
  // list which they have access to.
  repeated Reason reasons = 2;

  // TransactionDetails encapsulates the information necessary to make this
  // write safe by describing the snapshot of the graph which the writer
  // observed. TurboCI Orchestrator will transactionally ensure that these nodes
  // haven't changed since the writer observed them.
  //
  // TurboCI Orchestrator will implicitly include all nodes which are being
  // written to - this message can provide additional nodes to that set.
  //
  // It is valid to include nodes which were absent from the snapshot, if the
  // writer wants to make its write conditional on their absence.
  //
  // Transaction Procedure:
  //   retry {
  //     nodes, snapshot_version = QueryNodes(...)
  //     # computations
  //
  //     more_nodes, _ = QueryNodes(..., ensure_version=snapshot_version)
  //     # This will cause QueryNodes to fail if any returned nodes have
  //     # a version greater than `snapshot_version`. This will allow the
  //     # transaction loop to retry.
  //
  //     # computations
  //
  //     if WriteNodes(..., txn={nodes+more_nodes, snapshot_version}) {
  //       # Success!
  //
  //       # It would be technically possible to use the written_version field from the
  //       # response to do another WriteNodes call, assuming you supply a subset of
  //       # the `nodes_observed` to the new write. However, if this second write fails,
  //       # you must restart the second write process from after the first Write.
  //       #
  //       # It is simplest to just start a second transaction loop, including potentially
  //       # re-reading the nodes_observed.
  //       break
  //     } else {
  //       # failure - retry from the top
  //     }
  //   }
  message TransactionDetails {
    // A list of all nodes observed which lead to this write.
    //
    // This SHOULD include all nodes which your computation used as inputs
    // for making a decision. If you locally filtered the GraphView before the
    // computation, it is OK to omit nodes which were filtered out, because you
    // would do the same write regardless of those filtered nodes' content.
    //
    // This MAY include nodes which were absent from the GraphView - this means
    // that the write is conditional on their absence (e.g. "I queried for X and
    // didn't find it, so I'm doing a write based on that information. If X DOES
    // exist at the time of the write, I want to abort and try again.").
    //
    // NOTE: If you are writing what you THINK are all new nodes, but haven't
    // done a query to verify this, just providing `txn` with `nodes_observed`
    // and `snapshot_version` left unset is sufficient to guard against the
    // nodes already being written. However, if you get
    // a TransactionConflictFailure because the nodes already exist, when you
    // recover make sure to do the query before you try the write again! You may
    // be conflicting with a previous incarnation of your own process!
    repeated ids.v1.Identifier nodes_observed = 1 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_OPTION,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK_RESULT_DATUM,
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE
    ];

    // The 'version' of the GraphView returned from QueryNodes.
    //
    // If multiple queries were made in this transaction, this revision MUST be
    // the first revision observed. Providing version.require to QueryNodes will
    // help enforce this.
    //
    // If `snapshot_version` is unset, it is treated as a 0 value (which means
    // that all `nodes_observed` plus all nodes being written in this request
    // must not already exist).
    optional Revision snapshot_version = 2;
  }
  // Set if the caller wants to make this write transactional with a subset of
  // the graph at a particular snapshot.
  //
  // If this is unset, then this is an 'oblivious write' and any valid writes
  // will apply/overwrite the current database state, assuming they are
  // semantically valid (i.e. it will still not be possible to change a Check's
  // realm, or roll a Check's state backwards, etc.).
  //
  // There are common cases where this will be left unset, for example when a
  // Stage Attempt updates its own progress based on its own internal state, or
  // when a Stage Attempt records results for a Check off of some internal
  // computation. It's allowed for a Stage Attempt to tie this progress update
  // to the state of the graph, but it's not expected or required.
  optional TransactionDetails txn = 3;

  // A description of modifications to make to a single Check.
  message CheckWrite {
    // The check to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `stage_attempt_token`, if it's provided.
    //
    // Otherwise, the Check must belong to the stage_attempt_token's WorkPlan,
    // or the caller must have the additional "turboci.workplans.writeExternal"
    // permission in the check's realm (or in the realm of the option/result
    // data).
    optional ids.v1.Check identifier = 1;

    // Realm to assign to this check.
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing realm.
    //
    // If absent and this CheckWrite creates the Check, the written Check will
    // copy its realm from the Stage doing the write (assuming
    // `stage_attempt_token` is set). If `stage_attempt_token` is unset and this
    // field is absent, the write will be rejected.
    optional string realm = 2 [(turboci).creation_only = true];

    // Kind to assign to this check.
    //
    // If this is set, and the Check DOES already exist, this MUST match the
    // existing Check kind.
    optional CheckKind kind = 3 [(turboci).creation_only = true];

    // The list of Options to write/overwrite.
    //
    // Must be unique on `RealmValue.value.type_url`.
    repeated RealmValue options = 4 [(turboci).check.editable = CHECK_STATE_PLANNING];

    // Dependency predicate for this Check.
    //
    // If set, used to populate the dependencies.edges and
    // dependencies.predicate fields in the target Check.
    //
    // To clear dependencies, set this to an empty DependencyGroup.
    optional DependencyGroup dependencies = 5 [
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).check.editable = CHECK_STATE_PLANNING
    ];

    // Write data to a Result for this Check.
    //
    // The Result to write in is keyed on:
    //   * The Stage Attempt (if stage_attempt_token is provided)
    //   * The caller's identity (if stage_attempt_token is absent)
    //
    // If the given keyed Result does not exist, it will be automatically
    // created. Multiple calls to WriteNodes from this same StageAttempt or
    // service account will update the same Result, and the Result will be
    // automatically finalized when this StageAttempt ends (if a WriteNodes with
    // `finalize_results` is not called before then).
    //
    // The data here will overwrite existing data of the same type in the
    // selected Result for this StageAttempt.
    repeated RealmValue results = 6 [(turboci).check.editable = CHECK_STATE_WAITING];

    // If set, finalize the Check.Result.
    //
    // No more data may be written to the Result from the caller after this is
    // set.
    optional bool finalize_results = 7 [(turboci).check.editable = CHECK_STATE_WAITING];

    // The new state of this Check.
    //
    // If set, must be equal to, or greater than, the current state of the
    // Check.
    optional CheckState state = 8;
  }
  // Write to zero or more Checks.
  repeated CheckWrite checks = 4;

  // A description of modifications to make to a single Stage.
  //
  // Note that the `state` of a Stage is managed entirely by the Orchestrator
  // itself. If you are a Stage implementation and need to manage the state of
  // your own StageAttempt, see CurrentStageWrite.
  message StageWrite {
    // The stage to write to.
    //
    // If the WorkPlan is left blank, will be populated with the WorkPlan in
    // `stage_attempt_token`, if it's provided.
    //
    // Otherwise, the Stage must belong to the stage_attempt_token's WorkPlan,
    // or the caller must have the additional "turboci.workplans.writeExternal"
    // permission in the stage's realm.
    //
    // The `is_worknode` field should also be omitted - it will be filled in by
    // the server according to the type of `args`.
    optional ids.v1.Stage identifier = 1;

    // The arguments of the Stage.
    //
    // A Stage MUST have `args` - if this write would create the Stage and
    // `args` is omitted, the write will be rejected.
    //
    // TBD: Document executor registration/selection process.
    //
    // TBD: What to do on double-creation? Do we compare args (protobuf
    // serialization is not canonical/deterministic, but in practice if the
    // same process creates the same stage twice, it will likely have the same
    // args).
    //
    // We could just accept 'same type' == OK and ignore the value, but this
    // feels a bit wishy-washy.
    optional Value args = 2 [(turboci).creation_only = true];

    // Realm to assign to this Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing realm.
    //
    // If absent, the written Stage will copy its realm from the Stage doing
    // the write (assuming `stage_attempt_token` is set). If
    // `stage_attempt_token` is unset and this field is absent, the write will
    // be rejected.
    optional string realm = 3 [(turboci).creation_only = true];

    // Dependency predicate for this Stage.
    //
    // If set, used to populate the dependencies.edges and
    // dependencies.predicate fields in the target Check.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing dependencies identically.
    //
    // NOTE: Currently Stages in this group must only point to Stages created by
    // the Stage performing this write. In theory, this should help prevent
    // excessive coupling between different, unrelated, stage implementations.
    //
    // If arbitrary stage dependencies are allowed, it could cause errors when
    // an upstream stage changes it's implementation and no longer produces the
    // stages the downstream one expects. Instead, the upstream stage should
    // create a Check which can remain stable across the implementation
    // versions, and the downstream stages should depend on that.
    //
    // However, if the current writer is the one creating the stages, then there
    // is no implementation risk.
    optional DependencyGroup dependencies = 4 [
      (turboci).id.allowed = IDENTIFIER_KIND_STAGE,
      (turboci).id.allowed = IDENTIFIER_KIND_CHECK,
      (turboci).creation_only = true
    ];

    // The requested retry policy of the Stage.
    //
    // If the Stage already exists, this will only result in an error if this
    // requested policy doesn't match doesn't match the existing requested policy.
    //
    // If this write creates the stage and the requested_stage_execution_policy is
    // omitted, the stage will get the default StageExecutionPolicy from the
    // Executor.
    optional StageExecutionPolicy requested_stage_execution_policy = 5 [(turboci).creation_only = true];

    // The Check assignments of the Stage.
    //
    // If the Stage already exists, this will only result in an error if it
    // doesn't match the existing assignments.
    repeated Stage.Assignment assignments = 6 [(turboci).creation_only = true];

    // If true, ensures that this Stage is marked for cancellation.
    //
    // If the Stage is in the ATTEMPTING state, and the current Attempt is
    // RUNNING, the Attempt will transition to CANCELLING - Otherwise the
    // current Attempt will be marked INCOMPLETE.
    //
    // If the Stage is already marked for cancellation, setting this is a no-op.
    //
    // A value of `false` is the same as `unset` (no-op).
    //
    // Use the top-level `reason` field to provide the cancellation reason.
    optional bool cancelled = 7;

    // TBD: Other Adjustments ?
    // TBD: Dynamic Execution Policy
  }
  // Write to zero or more Stages.
  repeated StageWrite stages = 5;

  // Internal writes for the Stage indicated by the token.
  //
  // These aspects come from either the Executor which owns this Stage Attempt,
  // or the running Stage Attempt process.
  message CurrentStageWrite {
    // Report the attempt's current state. This can only make the following
    // transitions (since all other transitions are handled by the Orchestrator
    // itself):
    //
    //   * PENDING -> SCHEDULED
    //   * PENDING -> RUNNING
    //   * PENDING -> COMPLETE
    //   * PENDING -> INCOMPLETE
    //   * SCHEDULED -> RUNNING
    //   * SCHEDULED -> COMPLETE
    //   * SCHEDULED -> INCOMPLETE
    //   * RUNNING -> TEARING_DOWN
    //   * RUNNING -> COMPLETE
    //   * RUNNING -> INCOMPLETE
    optional StageAttemptState state = 1;

    // Sets the StageAttempt.process_uid field.
    //
    // MUST be supplied when transitioning a StageAttempt to RUNNING.
    //
    // If the field is already populated in the StageAttempt, this value must
    // match - otherwise the write is rejected with an error detail of
    // StageAttemptClaimedFailure.
    //
    // Refer to Stage.Attempt.process_uid.
    optional string process_uid = 2;

    // Continuation Group predicate for this Stage.
    //
    // If set, used to populate the continuation_group.edges and
    // continuation_group.predicate fields in this Stage.
    //
    // Edges here must only point to Stages which were created_by this Stage.
    optional DependencyGroup continuation_group = 3 [(turboci).id.allowed = IDENTIFIER_KIND_STAGE];

    // The modified execution policy for this Stage Attempt.
    //
    // This field can only be set by the stage executor when advancing the
    // stage attempt state PENDING -> (SCHEDULED|RUNNING).
    optional StageAttemptExecutionPolicy attempt_execution_policy = 4;

    // Adds details to the Stage Attempt.details field.
    //
    // If a data type here is already present in the database, the data here
    // must exactly equal the existing data; Otherwise the write is rejected.
    repeated Value details = 5;

    // Progress messages to add to the current StageAttempt.
    //
    // It is a good idea to do these progress updates transactionally, otherwise
    // it's possible to double-append them.
    repeated StageAttemptProgress progress = 6;
  }
  // State for the current Stage as indicated by `stage_attempt_token`.
  //
  // It is invalid to set this without also setting `stage_attempt_token`.
  //
  // All WriteNodes calls with a token act as a heartbeat for the current Stage
  // Attempt indicated by the token. If you need to implement the 'simplest
  // heartbeat', you can make a WriteNodes call with the token set and nothing
  // else.
  //
  // TBD: Document the SCHEDULED -> RUNNING state transition requirements (i.e.
  // setting a unique worker_id and handling multiple logicall processes all
  // trying to transition to RUNNING at the same time).
  optional CurrentStageWrite current_stage = 6;
}
