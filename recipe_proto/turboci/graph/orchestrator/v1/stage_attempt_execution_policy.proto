// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "google/protobuf/duration.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1;orchestratorpb";
option java_multiple_files = true;

// StageAttemptExecutionPolicy describes constraints on how a StageAttempt
// may be executed by the Orchestrator.
message StageAttemptExecutionPolicy {
  // Heartbeat indicates the minimum heartbeat interval for Stage Attempts in
  // a given state.
  //
  // Heartbeats allow the Orchestrator to detect missing stages sooner than
  // the execution timeout, by declaring non-receipt of a heartbeat message for
  // a certain amount of time to mean that the stage is gone and should be
  // treated accordingly.
  //
  // If, say, `scheduled` is 30s, it means that the executor must send
  // a heartbeat RPC (a WriteNodes RPC with `current_stage` populated, even
  // if it is empty) at least once every 30s while the Stage Attempt is
  // in the SCHEDULED state. It's allowed to heartbeat faster than this
  // interval, but shouldn't be necessary.
  //
  // In addition, we want to ensure that a single lost heartbeat doesn't time
  // out an expensive stage that might be close to completion, so the
  // Orchestrator will allow 1 missed heartbeat before declaring the next
  // non-received heartbeat to mean the stage is gone and should be marked
  // INCOMPLETE. However, missing/late heartbeats will be monitored and alerted
  // on, as they are likely pre-indicators of something about to go wrong.
  //
  // In other words, if the Orchestrator doesn't get an RPC from the Stage
  // Attempt before missing 2 heartbeats the Orchestrator will mark the Stage
  // Attempt as INCOMPLETE.
  //
  // It is expected that clients writing heartbeats will write them at an
  // interval faster than the minimum required here to account for network
  // latency and delays (including contention on a busy client machine).
  // A suggested rule of thumb is to heartbeat at an interval which is 90% of
  // the interval here. So if there is a 30s interval for RUNNING, the client
  // would target doing the RPC to heartbeat every 27 seconds. Ultimately,
  // though, it's up to the Executor how to ensure that a heartbeat gets to the
  // Orchestrator under this deadline.
  //
  // The fields here correspond to StageAttemptState values where a heartbeat
  // is applicable.
  //
  // It is TYPICAL to only define a heartbeat for `running`.
  //
  // Heartbeat intervals, if set, currently cannot exceed 30 minutes.
  message Heartbeat {
    // No pending heartbeat because this is before TurboCI has sent the
    // Stage Attempt to the Executor.

    // The expected duration that a Stage Attempt can be in the SCHEDULED
    // state without sending a heartbeat.
    //
    // If unset, then there is no required heartbeat cadence, though the stage
    // is still subject to timeouts for the phase.
    optional google.protobuf.Duration scheduled = 1;

    // The expected duration that a Stage Attempt can be in the RUNNING state
    // without sending a heartbeat.
    //
    // If unset, then there is no required heartbeat cadence, though the stage
    // is still subject to timeouts for the phase.
    //
    // NOTE: This heartbeat still applies during the CANCELLING state - it's
    // expected that CANCELLING only applies to Stage Attempts which are
    // RUNNING, but before the Stage Attempt actually knows this.
    optional google.protobuf.Duration running = 2;

    // The expected duration that a Stage Attempt can be in the TEARING_DOWN
    // state without sending a heartbeat.
    //
    // If unset, then there is no required heartbeat cadence, though the stage
    // is still subject to timeouts for the phase.
    optional google.protobuf.Duration tearing_down = 3;
  }
  // The heart policies for the StageAttempt.
  optional Heartbeat heartbeat = 1;

  // Timeout describes the maximum amount of time a Stage Attempt can be in a
  // given state (in addition to restrictions imposed by Heartbeat).
  //
  // The Orchestrator will automatically transition a Stage Attempt to
  // INCOMPLETE after the timeout has passed if the Stage Attempt has not yet
  // transitioned to the next state.
  //
  // Individual fields (or the entire `timeout` field) can be unset or be zero
  // when a StageAttemptExecutionPolicy is written via WriteNodes RPC. Such
  // policy will be sent to the executor as is in the ValidateStage RPC. The
  // executor must fill it in with defaults as it sees fit. Any fields that
  // still remain unset after that will be treated as zero (this make sense
  // in case the executor doesn't support SCHEDULED state or it is a
  // synchronous executor that doesn't have explicit RUNNING state, etc.). The
  // only exception is `pending_throttled`: the orchestrator imposes its own
  // constraints on top of what the executor returns, since stage attempts
  // in PENDING/THROTTLED state are primarily handled by the orchestrator
  // itself.
  message Timeout {
    // The maximum amount of time a Stage Attempt can be PENDING/THROTTLED.
    //
    // It is calculated from the time the Attempt first enters PENDING to the
    // time that it leaves PENDING for a non-THROTTLED state.
    //
    // If unset or zero, the orchestrator will use some default value.
    optional google.protobuf.Duration pending_throttled = 1;

    // The maximum amount of time a Stage Attempt can be SCHEDULED.
    //
    // If unset or zero, it is assumed the executor doesn't implement SCHEDULED
    // state.
    optional google.protobuf.Duration scheduled = 2;

    // The maximum amount of time a Stage Attempt can be RUNNING.
    //
    // NOTE: This timeout still applies during the CANCELLING state - it's
    // expected that CANCELLING only applies to Stage Attempts which are
    // RUNNING, but before the Stage Attempt actually knows this.
    //
    // If unset or zero, it is assumed the executor is a synchronous one, i.e.
    // it moves attempts immediately into COMPLETE or INCOMPLETE states,
    // bypassing SCHEDULED/RUNNING.
    optional google.protobuf.Duration running = 3;

    // The maximum amount of time a Stage Attempt can be TEARING_DOWN.
    //
    // Can be unset or zero if `running` is also unset or zero or if the
    // executor doesn't implement stage cancellation at all. Otherwise it should
    // be set to something to avoid premature termination of a cancelled
    // attempt as timed out during the tear down.
    optional google.protobuf.Duration tearing_down = 4;
  }
  // The timeout policies for the StageAttempt.
  optional Timeout timeout = 2;
}
