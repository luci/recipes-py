// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package turboci.graph.orchestrator.v1;

import "turboci/graph/orchestrator/v1/create_workplan_request.proto";
import "turboci/graph/orchestrator/v1/create_workplan_response.proto";
import "turboci/graph/orchestrator/v1/method_options.proto";
import "turboci/graph/orchestrator/v1/query_nodes_request.proto";
import "turboci/graph/orchestrator/v1/query_nodes_response.proto";
import "turboci/graph/orchestrator/v1/write_nodes_request.proto";
import "turboci/graph/orchestrator/v1/write_nodes_response.proto";

option go_package = "go.chromium.org/turboci/proto/go/graph/orchestrator/v1/grpcpb;orchestratorgrpcpb";
option java_multiple_files = true;

// TurboCIOrchestrator is the API for interacting with the TurboCI
// Orchestrator.
//
// These RPCs will require certain permissions, acquired via project-scoped
// LUCI ACLs (configured via
// https://chromium.googlesource.com/infra/luci/luci-go/+/refs/heads/main/lucicfg/doc/README.md#luci.binding),
// for the data being acted upon. A more complete description of the LUCI
// authorization model is at http://go/luci-authorization (Googlers only),
// with a more sparse description available to non-Googlers at
// https://chromium.googlesource.com/infra/luci/luci-go/+/refs/heads/main/lucicfg/doc/README.md#ACLs.
//
// Additional notes for understanding Turbo CI's use of this permissions model:
// * Every message has a LUCI realm (as a `string realm` field in these protos)
// either in the message or a containing message, and permissions to act on that
// message are configured for the realm.
// * Nested messages (e.g. a Check option inside of a Check) may be assigned to
// a different realm than their parent. Permission to read or write a nested
// message also requires the corresponding permission for all parent nodes, and
// for the containing Workplan.
service TurboCIOrchestrator {
  // CreateWorkPlan creates a new WorkPlan and returns a Workplan Creator
  // token, which can be used to create checks and stages in this Workplan.
  //
  // Currently can only create empty work plans that can later be populated via
  // WriteNodes call.
  rpc CreateWorkPlan(CreateWorkPlanRequest) returns (CreateWorkPlanResponse) {
    option (turboci_rpc) = {
      permission: {
        // There is no "internal" variant of this permission.
        //
        // By definition, there cannot be any tokens from inside the workplan
        // prior to the workplan's creation.
        external: "turboci.workplans.create"
        in: IDENTIFIER_KIND_WORK_PLAN
      }
    };
  }

  // WriteNodes transactionally writes or updates multiple nodes within a
  // WorkPlan.
  //
  // NOTE: Simple workflows can have all Checks, Check options and Stages in the
  // same realm, minimizing the number of required bindings.
  //
  // If a correctly encoded Stage Attempt token is used for
  // WriteNodesRequest.token, then a
  // turboci.graph.orchestrator.v1.StageAttemptCurrentState will be embedded as
  // an error detail, and the client is expected to respect the indicated
  // state.
  rpc WriteNodes(WriteNodesRequest) returns (WriteNodesResponse) {
    option (turboci_rpc) = {
      permission: {
        internal: "turboci.workplans.update"
        external: "turboci.workplans.updateExternal"
        in: IDENTIFIER_KIND_WORK_PLAN
        for: "all writes"
      }

      permission: {
        internal: "turboci.stages.create"
        external: "turboci.stages.createExternal"
        in: IDENTIFIER_KIND_STAGE
        for: "adding new stages"
      }

      permission: {
        internal: "turboci.stages.cancel"
        external: "turboci.stages.cancelExternal"
        in: IDENTIFIER_KIND_STAGE
        for: "cancelling stages"
      }

      permission: {
        internal: "turboci.stages.updateCurrent"
        in: IDENTIFIER_KIND_STAGE
        for: "updating current stage indicated by token"
        for: "updating current attempt indicated by token"
      }

      permission: {
        internal: "turboci.checks.write"
        external: "turboci.checks.writeExternal"
        in: IDENTIFIER_KIND_CHECK
        for: "creating checks"
        for: "updating checks"
        for: "writing check options"
        for: "writing check result data"
      }

      permission: {
        internal: "turboci.checkOptions.write"
        external: "turboci.checkOptions.writeExternal"
        in: IDENTIFIER_KIND_CHECK_OPTION
        for: "creating check options"
        for: "updating check options"
      }

      permission: {
        internal: "turboci.checkResultData.write"
        external: "turboci.checkResultData.writeExternal"
        in: IDENTIFIER_KIND_CHECK_RESULT_DATUM
        for: "creating check result data"
        for: "updating check result data"
      }
    };
  }

  // QueryNodes allows querying nodes in a fairly simple way.
  //
  // In the future we may add a more advanced API to open up more of GQL's
  // underlying expressiveness.
  //
  // If a correctly encoded Stage Attempt token is used for
  // QueryNodesRequest.token, then a
  // turboci.graph.orchestrator.v1.StageAttemptCurrentState will be embedded as
  // an error detail, and the client is expected to respect the indicated
  // state.
  rpc QueryNodes(QueryNodesRequest) returns (QueryNodesResponse) {
    option (turboci_rpc) = {
      permission: {
        internal: "turboci.checks.read"
        external: "turboci.checks.readExternal"
        in: IDENTIFIER_KIND_CHECK
        for: "reading checks and their associated values (options, result data, edits)"
      }

      permission: {
        internal: "turboci.checkOptions.read"
        external: "turboci.checkOptions.readExternal"

        in: IDENTIFIER_KIND_CHECK_OPTION
        for: "reading options in checks"

        in: IDENTIFIER_KIND_CHECK_EDIT_OPTION
        for: "reading options in check edits"
      }

      permission: {
        internal: "turboci.checkResultData.read"
        external: "turboci.checkResultData.readExternal"
        in: IDENTIFIER_KIND_CHECK_RESULT_DATUM
        for: "reading checks and their associated values (options, result data, edits)"
      }

      permission: {
        internal: "turboci.stages.read"
        external: "turboci.stages.readExternal"
        in: IDENTIFIER_KIND_CHECK
        for: "reading stages and their associated values (attempts, edits)"
      }

      permission: {
        internal: "turboci.stages.readCurrent"
        in: IDENTIFIER_KIND_CHECK
        for: "reading the stage and/or attempts associated with the provided token"
      }

      permission: {
        internal: "turboci.editReasons.read"
        external: "turboci.editReasons.readExternal"
        in: IDENTIFIER_KIND_CHECK_EDIT_REASON
        in: IDENTIFIER_KIND_STAGE_EDIT_REASON
        for: "reading edit reasons"
      }
    };
  }

  // TBD: Idempotent way to allocate N WorkNode IDs - this will allow safe node
  // ID allocation outside of a transaction so that WorkNodes can be
  // transactionally inserted.

  // TBD: An (idempotent) way to kick off a configured, named workplan.
  //
  // I don't think we will need to disambiguate kickoffs between different
  // callers at the same time for the same workplan configuration?
  //
  // Maybe use some 'template' verbiage here?
  //
  // Input should have the Any args that the initial stage should start with,
  // and the RPC should be able to do a basic type-check that this workplan
  // needs the given type. Maybe the initial args should be placed in a Check
  // with a well known name, and assigned to the initial Stage? This would allow
  // an easy entrypoint for e.g. a tightly-configured buildbucket build to be
  // the initial stage, but allow it to take differently-typed args depending on
  // the workplan it's used for. The registration of the workplan should still
  // list the expected types, though.
  //
  // Maybe this (and the RPCs to list workplan templates) should be a separate
  // service?
  //
  // rpc WorkPlanTemplateStart(WorkPlanTemplateStartRequest)
  //     returns (WorkPlanTemplateStartResponse)
  // {
  //   option deadline = 20;
  //   option (turboci_rpc) = {
  //     permission: "turboci.workplan.templates.start"
  //   };
  // }

  // TBD: RPC to list available workplan templates.
  //
  // rpc WorkPlanTemplatesList(WorkPlanTemplatesListRequest)
  //     returns (WorkPlanTemplatesListResponse) {
  //   option deadline = 20;
  //   option (turboci_rpc) = {
  //     permission: "turboci.workplan.templates.list"
  //   };
  // }
}
