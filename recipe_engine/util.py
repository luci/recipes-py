# Copyright (c) 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""This module holds utilities which make writing recipes easier."""

import contextlib as _contextlib
import itertools as _itertools
import os as _os

# These imports are intended to be passed through to recipes
# pylint: disable=W0611
from common.chromium_utils import IsWindows, IsMac, IsLinux

# e.g. /b/build/slave/<slave-name>/build
SLAVE_BUILD_ROOT = _os.path.abspath(_os.getcwd())
# e.g. /b
ROOT = _os.path.abspath(_os.path.join(SLAVE_BUILD_ROOT, _os.pardir, _os.pardir,
                                      _os.pardir, _os.pardir))
# e.g. /b/build_internal
BUILD_INTERNAL_ROOT = _os.path.join(ROOT, 'build_internal')
# e.g. /b/build
BUILD_ROOT = _os.path.join(ROOT, 'build')
# e.g. /b/depot_tools
DEPOT_TOOLS_ROOT = _os.path.join(ROOT, 'depot_tools')


def _path_method(name, base):
  """Returns a shortcut static method which functions like os.path.join with a
  fixed first component |base|.
  """
  def path_func_inner(*pieces):
    """This function returns a path to a file in '%s'."""
    assert _os.pardir not in pieces
    return _os.path.join(base, *pieces)
  path_func_inner.__name__ = name
  path_func_inner.__doc__ = path_func_inner.__doc__ % base
  return path_func_inner

# Recipes are expected to use each of these functions to generate paths for
# use in annotator steps. See the documentation for _path_method.
depot_tools_path = _path_method('depot_tools_path', DEPOT_TOOLS_ROOT)
build_internal_path = _path_method('build_internal_path', BUILD_INTERNAL_ROOT)
build_path = _path_method('build_path', BUILD_ROOT)
slave_build_path = _path_method('slave_build_path', SLAVE_BUILD_ROOT)

"""This function returns the equivalent of a path to a file in checkout root.
It is not a 'real' path because it contains a string token which must be
filled in by annotator_run.

Example (assuming that the checkout is a standard chromium checkout in 'src'):
  checkout_path('foobar')
    returns:
  "%(CheckoutRootPlaceholder)s/foobar"
    which, when run under annotator_run.py becomes:
  "/b/build/slave/win_rel/build/src/foobar"

The actual checkout root is filled in by annotated_run after the recipe
completes, and is dependent on the implementation of 'root()' in
annotated_checkout for the checkout type that you've selected.

NOTE: In order for this function to work, your recipe MUST use the 'checkout'
functionality provided by annotated_run.
"""  # pylint: disable=W0105
checkout_path = _path_method('checkout_path', '%(CheckoutRootPlaceholder)s')

def path_exists(path):
  return _os.path.exists(path)

@_contextlib.contextmanager
def mock_paths(paths_to_mock=None):
  """Used by unittest/recipes_test.py to temporarily override the paths
  generated by the various path functions in this module.

  This is necessary to give equivalent output when running the tests on any
  checkout configuration. Instead of real paths, recipes which use these
  functions will get paths like '[DEPOT_TOOLS_ROOT]'.
  """
  path_base_names = ['depot_tools', 'build_internal', 'build', 'slave_build',
                     'root']
  g = globals()
  tokens = {}
  path_funcs = {}
  paths_to_mock = frozenset(paths_to_mock or [])
  try:
    for name in path_base_names:
      token_name = (name + '_root').upper()
      token_val = '[%s]' % token_name
      path_func_name = (name + '_path')

      if token_name in g:
        tokens[token_name] = g[token_name]
        g[token_name] = token_val

      if path_func_name in g:
        path_funcs[path_func_name] = g[path_func_name]
        g[path_func_name] = _path_method(path_func_name, token_val)

    path_funcs['path_exists'] = g['path_exists']
    g['path_exists'] = lambda path: path in paths_to_mock

    yield
  finally:
    g.update(tokens)
    g.update(path_funcs)


def deep_set(obj, key_vals):
  """Take an object (a dict or list), and a list of key/value pairs to set,
  and transform it by replacing items in obj at the key locations with the
  respective values.

  keys are strings in the form of: (str|int)[.(str|int)]*

  Example:
    obj = {'some': {'deep': {'list': [1, 2, 3, 4, 5, 6]}}}
    key_vals = [("some.deep.list.3", 'foobar')]
    result = {'some': {'deep': {'list': [1, 2, 3, 'foobar', 5, 6]}}}
  """
  def try_int(x):
    try:
      x = int(x)
    except ValueError:
      pass
    return x

  for key, val in key_vals:
    cur_obj = obj
    components = key.split('.')
    for item in components[:-1]:
      cur_obj = cur_obj[try_int(item)]
    cur_obj[try_int(components[-1])] = val
  return obj


# This dict is used by _url_method. It contains a list of common base source
# control urls and their mirror urls. The format of the dict is:
#   { 'NamedUrl': ('<real url>', '<mirror url>'),
#     'OtherNamedUrl': ('<real url>',) }
SOURCE_URLS = {
  'ChromiumSvnURL': ('https://src.chromium.org',
                     'svn://svn-mirror.golo.chromium.org'),
  'ChromiumGitURL': ('https://chromium.googlesource.com',)
}

# This dict is used by Steps.gclient_common_spec. It contains standard
# configurations for commonly-needed gclient configurations. The format is:
#   { 'configname': lambda self: { ... gclient spec object ... } }
# self will be a Steps() instance.
GCLIENT_COMMON_SPECS = {
  'blink': lambda self: deep_set(
    GCLIENT_COMMON_SPECS['chromium'](self), [(
      'solutions.0.custom_deps',
      {'src/third_party/WebKit': self.ChromiumSvnURL('blink', 'trunk')}
    )]),

  'blink_bare': lambda self: {'solutions': [
    {
      'name': 'blink',
      'url': self.ChromiumSvnURL('blink', 'trunk'),
      'deps_file': '',
      'managed': True,
      'safesync_url': '',
    }]},

  'chromium': lambda self: {'solutions': [
    {
      'name': 'src',
      'url': self.ChromiumSvnURL('chrome', 'trunk', 'src'),
      'deps_file': 'DEPS',
      'managed': True,
      'custom_deps': {
        'src/third_party/WebKit/LayoutTests': None,
        'src/webkit/data/layout_tests/LayoutTests': None},
      'custom_vars': self.mirror_only({
        'googlecode_url': 'svn://svn-mirror.golo.chromium.org/%s',
        'nacl_trunk': 'http://src.chromium.org/native_client/trunk',
        'sourceforge_url': 'svn://svn-mirror.golo.chromium.org/%(repo)s',
        'webkit_trunk': 'svn://svn-mirror.golo.chromium.org/blink/trunk'}),
      'safesync_url': '',
    }]},

  'nacl': lambda self: {'solutions': [
    {
      'name': 'native_client',
      'url': self.ChromiumSvnURL(
        'native_client', 'trunk', 'src', 'native_client'),
      'custom_deps': {},
      'custom_vars': self.mirror_only({
        'webkit_trunk': 'svn://svn-mirror.golo.chromium.org/blink/trunk',
        'googlecode_url': 'svn://svn-mirror.golo.chromium.org/%s',
        'sourceforge_url': 'svn://svn-mirror.golo.chromium.org/%(repo)s'}),
    },
    {
      'name': 'supplement.DEPS',
      'url': self.ChromiumSvnURL(
        'native_client', 'trunk', 'deps', 'supplement.DEPS'),
      'custom_deps': {},
      'custom_vars': {},
    }]},

  'tools_build': lambda self: {'solutions': [
    {
      'name': 'build',
      'url': self.ChromiumGitURL('chromium', 'tools', 'build.git'),
      'managed': True,
      'deps_file': '.DEPS.git',
    }]},
}


class PropertyPlaceholder(object):
  """PropertyPlaceholder is meant to be a singleton object which, when added
  to a step's cmd list, will be replaced by annotated_run with the command
  parameters --factory-properties={...} and --build-properties={...} after
  your recipe terminates.

  Note that the 'steps' key will be absent from factory-properties. If you
  need to pass the list of steps to some of the steps, you will need to do
  that manually in your recipe (preferably with json.dumps()).

  This placeholder can be automatically added when you use the Steps.step()
  method in this module.
  """
PropertyPlaceholder = PropertyPlaceholder()

class JsonOutputPlaceholder(object):
  """JsonOutputPlaceholder is meant to be a singleton object which, when added
  to a step's cmd list, will be replaced by annotated_run with the command
  parameters --json-output=/path/to/file during the evaluation of your recipe
  generator.

  This placeholder can be optionally added when you use the Steps.step()
  method in this module.

  After the termination of the step, this file is expected to contain a valid
  JSON document, which will be set as the json_output for that step in the
  step_history OrderedDict passed to your recipe generator.
  """
JsonOutputPlaceholder = JsonOutputPlaceholder()


def _url_method(name):
  """Returns a shortcut static method which functions like os.path.join and uses
  a fixed first url component which is chosen from the urls defined in
  SOURCE_URLS based on |name|.
  """
  # note that we do the __name__ munging for each function separately because
  # staticmethod hides these attributes.
  bases = SOURCE_URLS[name]
  if len(bases) == 1:
    def url_func_inner_single(*pieces):
      """This function returns a url under '%s'."""
      return '/'.join((bases[0],) + pieces)
    url_func_inner_single.__name__ = name
    url_func_inner_single.__doc__ = url_func_inner_single.__doc__ % bases
    url_func_inner_single = staticmethod(url_func_inner_single)
    return url_func_inner_single
  else:
    def url_func_inner_mirror(self, *pieces):
      """This function returns a url under '%s' or (mirror) '%s'.
      The mirror setting is extracted as self.use_mirror
      """
      return '/'.join((bases[self.use_mirror],) + pieces)
    url_func_inner_mirror.__name__ = name
    url_func_inner_mirror.__doc__ = url_func_inner_mirror.__doc__ % bases
    return url_func_inner_mirror


class Steps(object):
  """Provides methods to build steps that annotator.py understands."""

  ChromiumSvnURL = _url_method('ChromiumSvnURL')
  ChromiumGitURL = _url_method('ChromiumGitURL')

  def __init__(self, build_properties):
    self.build_properties = build_properties
    self.use_mirror = self.build_properties.get('use_mirror', True)

  def mirror_only(self, obj):
    """Returns obj if we're using mirrors. Otherwise returns the 'empty'
    version of obj.
    """
    return obj if self.use_mirror else obj.__class__()

  @staticmethod
  def step(name, cmd, add_properties=False, add_json_output=False, **kwargs):
    """Returns a step dictionary which is compatible with annotator.py.

    Uses PropertyPlaceholder as a stand-in for build-properties and
    factory-properties so that annotated_run can fill them in after the recipe
    completes.

    Args:
      name: The name of this step.
      cmd: A list of strings in the style of subprocess.Popen.
      add_properties: Add PropertyPlaceholder iff True
      add_json_output: Add JsonOutputPlaceholder iff True
      **kwargs: Additional entries to add to the annotator.py step dictionary.

    Returns:
      A step dictionary which is compatible with annotator.py.
    """
    assert 'shell' not in kwargs
    assert isinstance(cmd, list)
    if add_properties:
      cmd += [PropertyPlaceholder]
    if add_json_output:
      cmd += [JsonOutputPlaceholder]
    ret = kwargs
    ret.update({'name': name, 'cmd': cmd})
    return ret

  def apply_issue(self, *root_pieces):
    return self.step('apply_issue', [
        depot_tools_path('apply_issue'),
        '-r', checkout_path(*root_pieces),
        '-i', self.build_properties['issue'],
        '-p', self.build_properties['patchset'],
        '-s', self.build_properties['rietveld'],
        '-e', 'commit-bot@chromium.org'])

  def git(self, *args, **kwargs):
    name = 'git '+args[0]
    # Distinguish 'git config' commands by the variable they are setting.
    if args[0] == 'config' and not args[1].startswith('-'):
      name += ' ' + args[1]
    if 'cwd' not in kwargs:
      kwargs.setdefault('cwd', checkout_path())
    return self.step(name, ['git'] + list(args), **kwargs)

  def generator_script(self, path_to_script, *args):
    def step_generator(step_history, _failure):
      yield self.step(
        'gen step(%s)' % _os.path.basename(path_to_script),
        [path_to_script,] + list(args),
        add_json_output=True,
        cwd=checkout_path())
      new_steps = step_history.last_step().json_data
      assert isinstance(new_steps, list)
      yield new_steps
    return step_generator

  def git_checkout(self, url, dir_path=None, branch='master', recursive=False,
                   keep_paths=None):
    """Returns an iterable of steps to perform a full git checkout.
    Args:
      url (string): url of remote repo to use as upstream
      dir_path (string): optional directory to clone into
      branch (string): branch to check out after fetching
      recursive (bool): whether to recursively fetch submodules or not
      keep_paths (iterable of strings): paths to ignore during git-clean;
          paths are gitignore-style patterns relative to checkout_path.
    """
    if not dir_path:
      dir_path = url.rsplit('/', 1)[-1]
      if dir_path.endswith('.git'):  # ex: https://host/foobar.git
        dir_path = dir_path[:-len('.git')]
      if not dir_path:  # ex: ssh://host:repo/foobar/.git
        dir_path = dir_path.rsplit('/', 1)[-1]
      dir_path = slave_build_path(dir_path)
    assert _os.pardir not in dir_path
    recursive_args = ['--recurse-submodules'] if recursive else []
    clean_args = list(_itertools.chain(
        *[('-e', path) for path in keep_paths or []]))
    return [
      self.step(
        'git setup', [
          build_path('scripts', 'slave', 'git_setup.py'),
          '--path', dir_path,
          '--url', url,
        ],
        static_json_data={
          'CheckoutRoot': dir_path,
          'CheckoutSCM': 'git',
          'CheckoutSpec': {
            'url': url,
            'recursive': recursive,
          },
        }),
      self.git('fetch', 'origin', *recursive_args),
      self.git('update-ref', 'refs/heads/'+branch, 'origin/'+branch),
      self.git('clean', '-f', '-d', '-x', *clean_args),
      self.git('checkout', '-f', branch),
      self.git('submodule', 'update', '--init', '--recursive', cwd=dir_path),
    ]

  def gclient_checkout(self, common_repo_name_or_spec, git_mode=False,
                       spec_name=None):
    """Returns a step generator function for gclient checkouts."""
    if isinstance(common_repo_name_or_spec, basestring):
      spec = GCLIENT_COMMON_SPECS[common_repo_name_or_spec](self)
    else:
      spec = common_repo_name_or_spec
    spec_string = ''
    if not spec_name:
      step_name = lambda n: 'gclient ' + n
    else:
      step_name = lambda n: '[spec: %s] gclient %s' % (spec_name, n)
    for key in spec:
      # We should be using json.dumps here, but gclient directly execs the dict
      # that it receives as the argument to --spec, so we have to have True,
      # False, and None instead of JSON's true, false, and null.
      spec_string += '%s = %s\n' % (key, str(spec[key]))
    gclient = depot_tools_path('gclient') + ('.bat' if IsWindows() else '')

    if not git_mode:
      clean_step = self.step(step_name('clean'),
                             [gclient, 'revert', '--nohooks'])
      sync_step = self.step(step_name('sync'), [gclient, 'sync', '--nohooks'])
    else:
      # clean() isn't used because the gclient sync flags passed in checkout()
      # do much the same thing, and they're more correct than doing a separate
      # 'gclient revert' because it makes sure the other args are correct when
      # a repo was deleted and needs to be re-cloned (notably
      # --with_branch_heads), whereas 'revert' uses default args for clone
      # operations.
      #
      # TODO(mmoss): To be like current official builders, this step could just
      # delete the whole <slave_name>/build/ directory and start each build
      # from scratch. That might be the least bad solution, at least until we
      # have a reliable gclient method to produce a pristine working dir for
      # git-based builds (e.g. maybe some combination of 'git reset/clean -fx'
      # and removing the 'out' directory).
      clean_step = None
      sync_step = self.step(step_name('sync'), [
        gclient, 'sync', '--verbose', '--with_branch_heads', '--nohooks',
                     '--reset', '--delete_unversioned_trees', '--force'])
    steps = [
      self.step(
        step_name('setup'),
        [gclient, 'config', '--spec', spec_string],
        static_json_data={
          'CheckoutRoot': slave_build_path(spec['solutions'][0]['name']),
          'CheckoutSCM': 'gclient',
          'CheckoutSpec': spec
        }
      ),
    ]
    if clean_step:
      steps.append(clean_step)
    if sync_step:
      steps.append(sync_step)

    return steps
